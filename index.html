<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><filter id='glow' x='-50%25' y='-50%25' width='200%25' height='200%25'><feGaussianBlur stdDeviation='4' result='blur'/><feMerge><feMergeNode in='blur'/><feMergeNode in='SourceGraphic'/></feMerge></filter></defs><rect width='100' height='100' rx='20' fill='%230c0a1e'/><text x='50' y='70' font-family='Arial, sans-serif' font-size='60' font-weight='bold' fill='%230ff' stroke='%23fff' stroke-width='1' text-anchor='middle' filter='url(%23glow)'>ID</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>잎코대쉬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
      :root {
        --glow-color: #0ff;
        --secondary-glow-color: #f0f;
        --danger-glow-color: #f00;
        --warn-glow-color: #ff0;
        --bg-color: #0c0a1e;
      }
      body {
        font-family: 'Noto Sans KR', sans-serif;
        background-color: var(--bg-color);
        overflow: hidden;
        touch-action: none;
      }
      @keyframes glow {
        0%, 100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--glow-color), 0 0 20px var(--glow-color); }
        50% { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px var(--glow-color), 0 0 40px var(--glow-color); }
      }
      .glowing-text {
        animation: glow 1.5s ease-in-out infinite;
      }
      @keyframes scroll-bg {
        0% { background-position: 0 0; }
        100% { background-position: -2000px 0; }
      }
      .scrolling-background {
          width: 100%;
          height: 100%;
          position: absolute;
          top: 0; left: 0;
          background: 
            radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%),
            url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><line x1="100" y1="0" x2="100" y2="200" stroke="rgba(0, 255, 255, 0.1)" stroke-width="1"/><line x1="0" y1="100" x2="200" y2="100" stroke="rgba(0, 255, 255, 0.1)" stroke-width="1"/></svg>'),
            url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50"><rect width="1" height="1" fill="rgba(255,255,255,0.2)"/></svg>');
          animation: scroll-bg 40s linear infinite;
          z-index: -1;
      }
      @keyframes fade-in {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }
       @keyframes overlay-fade-in {
        from { opacity: 0; backdrop-filter: blur(0px); }
        to { opacity: 1; backdrop-filter: blur(5px); }
      }
      .fade-in { animation: fade-in 0.5s ease-out forwards; }
      .overlay-fade-in { animation: overlay-fade-in 0.3s ease-out forwards; }
      
      /* Player Animations */
      @keyframes run-cycle { 0%, 100% { transform: translateY(0) rotate(-2deg); } 50% { transform: translateY(-6px) rotate(2deg); } }
      .player-running { animation: run-cycle 0.4s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
      .player-jumping { transform: rotate(-10deg); }
      .player-falling { transform: rotate(10deg); }
      @keyframes giant-stomp { 0%, 100% { transform: translateY(0) scale(1.5); } 50% { transform: translateY(-10px) scale(1.5); } }
      .player-giant { animation: giant-stomp 0.5s ease-in-out infinite; }

      /* Visual Effects */
      @keyframes hit-flash-anim { 0% { opacity: 0.5; } 100% { opacity: 0; } }
      .hit-flash-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: red; pointer-events: none; opacity: 0; animation: hit-flash-anim 0.2s ease-out; z-index: 100; }
      @keyframes last-dash-anim { 0%, 100% { box-shadow: inset 0 0 50px 20px rgba(255, 0, 0, 0.4); } 50% { box-shadow: inset 0 0 80px 30px rgba(255, 0, 0, 0.7); } }
      .last-dash-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; animation: last-dash-anim 0.5s ease-in-out infinite; z-index: 90; }
      @keyframes fever-glow { 0% { box-shadow: 0 0 20px 10px rgba(255, 235, 59, 0); } 50% { box-shadow: 0 0 40px 20px rgba(255, 235, 59, 0.4); } 100% { box-shadow: 0 0 20px 10px rgba(255, 235, 59, 0); } }
      .fever-active-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; animation: fever-glow 1s ease-in-out infinite; z-index: 10; }
      .shield-effect { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 120%; height: 120%; border: 4px solid #0ff; border-radius: 50%; box-shadow: 0 0 15px #0ff; opacity: 0.7; animation: glow 1.5s ease-in-out infinite alternate; }
      
      /* New Mobile UI Elements */
      .ui-button {
        background-color: rgba(0, 255, 255, 0.2);
        border: 2px solid var(--glow-color);
        border-radius: 12px;
        padding: 12px 24px;
        color: white;
        font-weight: bold;
        text-shadow: 0 0 5px var(--glow-color);
        transition: all 0.2s ease;
        -webkit-tap-highlight-color: transparent;
      }
      .ui-button:hover, .ui-button:active {
        background-color: rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 15px var(--glow-color);
        transform: scale(1.05);
      }
       .ui-button:disabled {
        background-color: rgba(128, 128, 128, 0.2);
        border-color: #888;
        color: #888;
        text-shadow: none;
        cursor: not-allowed;
        transform: scale(1);
      }
      .selection-card {
        border: 2px solid #555;
        background: rgba(255,255,255,0.05);
        border-radius: 12px;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .selection-card.selected {
        border-color: var(--glow-color);
        box-shadow: 0 0 15px var(--glow-color);
        transform: scale(1.05);
      }
      .progress-bar-container {
        background-color: rgba(0,0,0,0.5);
        border-radius: 9999px;
        padding: 2px;
        border: 1px solid #555;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        border-radius: 9999px;
        transition: width 0.3s ease;
      }
      .health-bar { background: linear-gradient(90deg, #ff4d4d, #a3ff4d); }
      .fever-bar { background: linear-gradient(90deg, #ff9800, #ffeb3b); box-shadow: 0 0 10px #ffeb3b; }

      .control-button {
        position: absolute;
        bottom: 5vh;
        width: 18vh;
        height: 18vh;
        max-width: 120px;
        max-height: 120px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        transition: all 0.1s ease-out;
      }
      .control-button:active {
        background-color: rgba(0, 255, 255, 0.4);
        border-color: var(--glow-color);
        transform: scale(1.1);
      }
      .nav-button {
        background: none;
        border: none;
        color: #888;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        font-size: 12px;
        font-weight: bold;
        transition: color 0.2s ease;
      }
      .nav-button:hover, .nav-button.active {
        color: var(--glow-color);
        text-shadow: 0 0 8px var(--glow-color);
      }
      .main-overlay {
        position: absolute;
        inset: 0;
        z-index: 50;
        background: rgba(12, 10, 30, 0.8);
        backdrop-filter: blur(5px);
        display: flex;
        flex-direction: column;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react": "https://esm.sh/react@18.2.0"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script type="module">
        import React from 'react';
        import ReactDOM from 'react-dom/client';

        // --- START OF COMBINED GAME CODE ---

        // --- START OF MERGED types.ts ---
        const IVector2D = {}; const CharacterSkill = {}; const PetSkill = {}; const TreasureType = {}; const MissionType = {}; const RewardType = {}; const PartnerBonusType = {}; const GameObjectType = {}; const GameStatus = {};
        // --- END OF MERGED types.ts ---

        // --- START OF MERGED constants.tsx ---

        const WORLD_WIDTH = 1280; const WORLD_HEIGHT = 720; const GROUND_HEIGHT = 60; const GRAVITY = 3000; const PLAYER_X_POSITION = 150;
        const PLAYER_JUMP_FORCE = 1100; const PLAYER_RUN_SIZE = { x: 50, y: 70 }; const PLAYER_SLIDE_SIZE = { x: 70, y: 40 };
        const INITIAL_MAX_HEALTH = 100; const HEALTH_DECAY_RATE = 2.0; const OBSTACLE_DAMAGE = 60; // Damage per second
        const INITIAL_GAME_SPEED = 400; const GAME_SPEED_INCREASE_RATE = 4;
        const FEVER_GAUGE_MAX = 100; const FEVER_GAUGE_PER_JELLY = 5; const FEVER_DURATION = 8; const FEVER_OBSTACLE_SCORE = 100;
        const LAST_DASH_DURATION = 3;
        const GIANT_POTION_DURATION = 8; const BLAST_JELLY_DURATION = 1.5; const BLAST_JELLY_SPEED_MULTIPLIER = 2.5; const MAGNET_ITEM_DURATION = 10; const MAGNET_RADIUS = 250;

        const SvgIconWrapper = ({ children, color, filterId, className }) => (
            React.createElement('svg', { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", className: className || "w-full h-full", style: { filter: `url(#${filterId})` } },
                React.createElement('defs', null, React.createElement('filter', { id: filterId },
                    React.createElement('feDropShadow', { dx: "0", dy: "0", stdDeviation: "5", floodColor: color }),
                    React.createElement('feDropShadow', { dx: "0", dy: "0", stdDeviation: "8", floodColor: color })
                )),
                children
            )
        );

        const CHARACTERS = {
            'char1': { id: 'char1', name: '네온 스트라이커', description: '기본에 충실한 밸런스형 런너입니다.', skill: 'none', maxLevel: 10, baseStat: 100, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#0ff", filterId: "char1-glow", className: className }, React.createElement('rect', { x: "25", y: "30", width: "50", height: "70", rx: "10", fill: "#0ff", stroke: "#fff", strokeWidth: "5" }), React.createElement('circle', { cx: "50", cy: "30", r: "20", fill: "#0ff", stroke: "#fff", strokeWidth: "5" })) },
            'char2': { id: 'char2', name: '마젠타 팬텀', description: '더 높은 체력을 가지고 오래 버팁니다.', skill: 'extra_health', maxLevel: 10, baseStat: 120, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#f0f", filterId: "char2-glow", className: className }, React.createElement('polygon', { points: "50,10 90,90 10,90", fill: "#f0f", stroke: "#fff", strokeWidth: "5" })) },
            'char3': { id: 'char3', name: '볼텍스', description: '게임 시작 시 자석 효과를 가지고 시작합니다.', skill: 'start_magnet', maxLevel: 10, baseStat: 90, unlockCost: 4000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#9400D3", filterId: "char3-glow", className: className }, React.createElement('path', { d: "M50 10 C 90 10, 90 90, 50 90 S 10 90, 10 10 C 10 10, 50 10, 50 10 Z", transform: "rotate(45 50 50)", fill: "none", stroke: "#9400D3", strokeWidth: "6" }), React.createElement('circle', { cx: "50", cy: "50", r: "10", fill: "#fff" })) },
            'char4': { id: 'char4', name: '크로노', description: '체력이 50% 이하가 되면 게임 속도가 느려집니다.', skill: 'time_slow', maxLevel: 10, baseStat: 100, unlockCost: 10000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#00fa9a", filterId: "char4-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "40", fill: "none", stroke: "#00fa9a", strokeWidth: "6", strokeDasharray: "10 5" }), React.createElement('path', { d: "M50 20 V50 H70", fill: "none", stroke: "#fff", strokeWidth: "6" })) },
            'char5': { id: 'char5', name: '블레이즈', description: '게임 속도가 더 빠르지만, 점수 보너스를 얻습니다.', skill: 'high_speed', maxLevel: 10, baseStat: 80, unlockCost: 12000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff4500", filterId: "char5-glow", className: className }, React.createElement('path', { d: "M50 10 L60 40 L90 45 L65 65 L70 95 L50 80 L30 95 L35 65 L10 45 L40 40 Z", fill: "#ff4500", stroke: "#fff", strokeWidth: "4" })) },
            'char6': { id: 'char6', name: '클로버', description: '게임에 아이템이 더 자주 등장합니다.', skill: 'item_boost', maxLevel: 10, baseStat: 100, unlockCost: 8000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#32cd32", filterId: "char6-glow", className: className }, React.createElement('path', { d: "M50 25 C 30 5, 30 40, 50 50 C 70 40, 70 5, 50 25 Z", fill: "#32cd32" }), React.createElement('path', { d: "M75 50 C 95 30, 60 30, 50 50 C 60 70, 95 70, 75 50 Z", fill: "#32cd32" }), React.createElement('path', { d: "M50 75 C 30 95, 30 60, 50 50 C 70 60, 70 95, 50 75 Z", fill: "#32cd32" }), React.createElement('path', { d: "M25 50 C 5 30, 40 30, 50 50 C 40 70, 5 70, 25 50 Z", fill: "#32cd32" })) },
            'char7': { id: 'char7', name: '시너지', description: '장착한 펫의 능력이 20% 향상됩니다.', skill: 'pet_boost', maxLevel: 10, baseStat: 100, unlockCost: 15000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#fafad2", filterId: "char7-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "30", fill: "none", stroke: "#fafad2", strokeWidth: "6" }), React.createElement('circle', { cx: "50", cy: "50", r: "15", fill: "#fafad2" })) },
            'char8': { id: 'char8', name: '피닉스', description: '최후의 질주 시간이 50% 증가합니다.', skill: 'last_dash_boost', maxLevel: 10, baseStat: 100, unlockCost: 18000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff8c00", filterId: "char8-glow", className: className }, React.createElement('path', { d: "M20 80 Q 50 20, 80 80 Q 50 50, 20 80 Z", fill: "#ff8c00" }), React.createElement('path', { d: "M30 70 Q 50 30, 70 70 Q 50 55, 30 70 Z", fill: "#ff4500", stroke:"#fff", strokeWidth:"2" })) },
        };

        const PETS = {
            'pet1': { id: 'pet1', name: '큐브', description: '일정 시간마다 체력 포션을 생성합니다.', skill: 'health_potion', maxLevel: 10, baseStat: 20, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#fff", filterId: "pet1-glow", className: className }, React.createElement('rect', { x: "20", y: "20", width: "60", height: "60", rx: "10", fill: "#fff", stroke: "#000", strokeWidth: "5", transform: "rotate(45 50 50)" })) },
            'pet2': { id: 'pet2', name: '윙키', description: '젤리 획득 시 추가 점수를 줍니다.', skill: 'score_bonus', maxLevel: 10, baseStat: 1, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff0", filterId: "pet2-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "30", fill: "#ff0" }), React.createElement('path', { d: "M 35,40 Q 50,60 65,40", stroke: "black", strokeWidth: "5", fill: "none" })) },
            'pet3': { id: 'pet3', name: '실드론', description: '일정 시간마다 보호막 아이템을 생성합니다.', skill: 'shield_item', maxLevel: 10, baseStat: 30, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#40E0D0", filterId: "pet3-glow", className: className }, React.createElement('path', { d: "M50 10 L90 30 L90 70 L50 90 L10 70 L10 30 Z", fill: "#40E0D0", stroke: "#fff", strokeWidth: "5" }), React.createElement('path', { d: "M50 25 L75 40 L75 60 L50 75 L25 60 L25 40 Z", fill: "none", stroke: "#fff", strokeWidth: "5" })) },
            'pet4': { id: 'pet4', name: '스파크', description: '젤리 획득 시 피버 게이지를 추가로 채웁니다.', skill: 'fever_boost', maxLevel: 10, baseStat: 1, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ffa500", filterId: "pet4-glow", className: className }, React.createElement('path', { d: "M50 10 L40 45 H60 L50 90 L60 55 H40 Z", fill: "#ffa500", stroke: "#fff", strokeWidth: "4" })) },
            'pet5': { id: 'pet5', name: '제트', description: '체력이 0이 되면, 한 번 부활합니다 (체력 25%).', skill: 'revive', maxLevel: 1, baseStat: 1, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#b0c4de", filterId: "pet5-glow", className: className }, React.createElement('path', { d: "M50 20 L70 40 L60 45 L80 65 L50 90 L20 65 L40 45 L30 40 Z", fill: "#b0c4de", stroke: "#fff", strokeWidth: "4" })) },
            'pet6': { id: 'pet6', name: '마이더스', description: '게임 종료 시 획득하는 젤리가 증가합니다.', skill: 'currency_boost', maxLevel: 10, baseStat: 5, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ffd700", filterId: "pet6-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "35", fill: "#ffd700", stroke: "#fff", strokeWidth: "4" }), React.createElement('text', { x: "50", y: "65", fontSize: "40", textAnchor: "middle", fill: "black", fontWeight: "bold" }, "J")) },
            'pet7': { id: 'pet7', name: '수호령', description: '5% 확률로 장애물 피해를 무시합니다.', skill: 'damage_negation', maxLevel: 10, baseStat: 5, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#add8e6", filterId: "pet7-glow", className: className }, React.createElement('path', { d: "M50 20 C 30 40, 30 70, 50 80 C 70 70, 70 40, 50 20 Z", fill: "#add8e6", opacity:"0.7" }), React.createElement('circle', { cx: "50", cy: "50", r: "5", fill: "#fff" })) },
            'pet8': { id: 'pet8', name: '듀라', description: '모든 아이템의 지속 시간이 25% 증가합니다.', skill: 'item_duration_boost', maxLevel: 1, baseStat: 0.25, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#cd853f", filterId: "pet8-glow", className: className }, React.createElement('path', { d: "M30 20 H70 L60 50 L70 80 H30 L40 50 Z", fill: "#cd853f", stroke: "#fff", strokeWidth: "4" })) },
        };
        
        const PARTNER_BONUSES = {
            'char1_pet1': { name: '단단한 유대', description: '최대 체력 +15', type: 'max_health_bonus', value: 15 }, 'char2_pet2': { name: '황금 듀오', description: '젤리 획득 점수 +10%', type: 'jelly_score_bonus', value: 0.1 }, 'char5_pet4': { name: '타오르는 열정', description: '피버 지속 시간 +15%', type: 'fever_duration_bonus', value: 0.15 }, 'char7_pet3': { name: '완벽한 방어', description: '펫 스킬 쿨타임 -25%', type: 'pet_cooldown_reduction', value: 0.25 }, 'char8_pet5': { name: '불사조의 의지', description: '부활 시 체력 50%로 부활', type: 'revive_health_bonus', value: 0.5 }, 'char6_pet6': { name: '행운의 부자', description: '게임 종료 젤리 보너스 +10%', type: 'currency_bonus_final', value: 0.1 }, 'char3_pet7': { name: '자기장 강화', description: '자석 아이템 지속 시간 +30%', type: 'magnet_duration_bonus', value: 0.3 }, 'char4_pet8': { name: '시간의 지배자', description: '슬로우 효과 지속 시간 +20%', type: 'slow_duration_bonus', value: 0.2 }, 'char1_pet2': { name: '러너스 하이', description: '기본 젤리 점수 +5', type: 'base_jelly_score_bonus', value: 5 }, 'char2_pet1': { name: '꺼지지 않는 체력', description: '체력 자연 감소 속도 -15%', type: 'health_decay_reduction', value: 0.15 }, 'char7_pet8': { name: '아이템 마스터', description: '모든 아이템 지속 시간 +10%', type: 'all_item_duration_bonus', value: 0.1 },
        };

        const TREASURES = {
            'tr1': { id: 'tr1', name: '빛나는 깃털', description: '점프 높이 +5%', type: 'jump_boost', value: 0.05 }, 'tr2': { id: 'tr2', name: '견고한 심장', description: '최대 체력 +10', type: 'health_bonus', value: 10 }, 'tr3': { id: 'tr3', name: '질주의 부츠', description: '기본 속도 +5%', type: 'speed_boost', value: 0.05 }, 'tr4': { id: 'tr4', name: '황금 나침반', description: '획득 점수 +5%', type: 'score_bonus', value: 0.05 }, 'tr5': { id: 'tr5', name: '열정의 불꽃', description: '피버 시간 +10%', type: 'fever_duration', value: 0.1 }, 'tr6': { id: 'tr6', name: '황금 젤리', description: '젤리 점수 +10%', type: 'base_jelly_score_percentage_bonus', value: 0.1 }, 'tr7': { id: 'tr7', name: '자력의 돌', description: '자석 시간 +20%', type: 'magnet_duration', value: 0.2 }, 'tr8': { id: 'tr8', name: '거인의 물약', description: '거인화 시간 +20%', type: 'giant_duration', value: 0.2 }, 'tr9': { id: 'tr9', name: '절약의 동전', description: '비용 -5%', type: 'cost_reduction', value: 0.05 }, 'tr10': { id: 'tr10', name: '행운의 네잎클로버', description: '상자 행운 증가', type: 'luck_boost', value: 0.1 },
        };

        const MISSIONS = [
            { id: 'm1', description: '젤리 500개 수집', type: 'collect_jellies', target: 500, reward: { currency: 100, treasureChests: 0 } }, { id: 'm2', description: '1,000m 달리기', type: 'run_distance', target: 1000, reward: { currency: 100, treasureChests: 0 } }, { id: 'm3', description: '장애물 20개 파괴', type: 'destroy_obstacles', target: 20, reward: { currency: 150, treasureChests: 0 } }, { id: 'm4', description: '점프 100번 하기', type: 'jump_count', target: 100, reward: { currency: 100, treasureChests: 0 } }, { id: 'm5', description: '피버 타임 5번 발동', type: 'fever_count', target: 5, reward: { currency: 200, treasureChests: 1 } }, { id: 'm6', description: '한 게임에서 10,000점 달성', type: 'single_run_score', target: 10000, reward: { currency: 250, treasureChests: 0 } }, { id: 'm7', description: '젤리 2,500개 수집', type: 'collect_jellies', target: 2500, reward: { currency: 300, treasureChests: 0 } }, { id: 'm8', description: '5,000m 달리기', type: 'run_distance', target: 5000, reward: { currency: 300, treasureChests: 0 } }, { id: 'm9', description: '아이템 25개 사용', type: 'use_items', target: 25, reward: { currency: 200, treasureChests: 0 } }, { id: 'm10', description: '총 50,000점 누적', type: 'total_score', target: 50000, reward: { currency: 500, treasureChests: 1 } },
        ];
        
        const ENHANCEMENTS = {
            'health': { name: '기본 체력 강화', description: (lvl) => `최대 체력 +${lvl * 5} 영구 증가`, maxLevel: 20, baseValue: 5 }, 'jelly_score': { name: '젤리 점수 강화', description: (lvl) => `모든 젤리 점수 +${lvl * 2}% 영구 증가`, maxLevel: 25, baseValue: 0.02 }, 'fever_duration': { name: '피버 시간 강화', description: (lvl) => `피버 시간 +${(lvl * 0.1).toFixed(1)}초 영구 증가`, maxLevel: 20, baseValue: 0.1 }, 'currency_gain': { name: '젤리 획득량 강화', description: (lvl) => `게임 종료 젤리 +${lvl * 2}% 영구 증가`, maxLevel: 25, baseValue: 0.02 }
        };
        const ENHANCEMENT_COST = (level, reduction = 0) => Math.floor(500 * Math.pow(1.2, level) * (1 - reduction));

        const LEVEL_UP_COST = (level, reduction = 0) => Math.floor((100 * Math.pow(level, 1.5)) * (1 - reduction));

        const getCharacterStat = (char, level) => char.baseStat + (level - 1) * 10;
        const getPetStat = (pet, level, isSynergy) => {
            let baseStat = 0;
            switch(pet.skill) {
                case 'health_potion': baseStat = Math.max(5, pet.baseStat - (level - 1)); break;
                case 'score_bonus': baseStat = pet.baseStat + (level - 1); break;
                case 'shield_item': baseStat = Math.max(10, pet.baseStat - (level - 1) * 2); break;
                case 'fever_boost': baseStat = pet.baseStat + (level - 1) * 0.5; break;
                case 'currency_boost': baseStat = pet.baseStat + (level - 1) * 2; break;
                case 'damage_negation': baseStat = pet.baseStat + (level - 1) * 0.5; break;
                default: baseStat = pet.baseStat; break;
            }
            if (isSynergy) {
                 if (['health_potion', 'shield_item'].includes(pet.skill)) return baseStat * 0.8;
                 return baseStat * 1.2;
            }
            return baseStat;
        };

        const ObstacleLowIcon = () => React.createElement('div', { className: "w-full h-full bg-red-500 border-2 border-white rounded-md", style: { boxShadow: '0 0 10px #f00' } });
        const ObstacleHighIcon = () => React.createElement('div', { className: "w-full h-full bg-red-500 border-2 border-white rounded-md", style: { boxShadow: '0 0 10px #f00' } });
        const ObstacleSpikesIcon = () => React.createElement('div', { className: "w-full h-full bg-red-800 flex justify-around items-end p-1", style: { boxShadow: '0 0 10px #f00' } }, Array(5).fill(0).map((_, i) => React.createElement('div', { key: i, style: { width: '15%', height: '100%', background: 'white', clipPath: 'polygon(50% 0, 0 100%, 100% 100%)' } })));
        const ObstacleFallingIcon = () => React.createElement('div', { className: "w-full h-full bg-red-700 rounded-full border-2 border-white flex items-center justify-center", style: { boxShadow: '0 0 15px #f00', animation: 'spin 1s linear infinite' } }, '▼');
        const JellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-yellow-300", style: { boxShadow: '0 0 8px #ff0' } });
        const BigJellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-yellow-300 relative flex items-center justify-center", style: { boxShadow: '0 0 15px #ff0' } }, React.createElement('div', { className: "w-1/2 h-1/2 rounded-full bg-white/50" }));
        const RainbowBearJellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-2xl", style: { background: 'linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)', animation: 'glow 1s ease-in-out infinite alternate', boxShadow: '0 0 20px #fff' } });
        const HealthPotionIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-green-400 border-2 border-white", style: { boxShadow: '0 0 10px #0f0' } });
        const GiantPotionIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-purple-500 border-2 border-white", style: { boxShadow: '0 0 10px #f0f' } });
        const BlastJellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-orange-500 border-2 border-white", style: { boxShadow: '0 0 10px #ff8c00' } });
        const ShieldItemIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-cyan-500 border-2 border-white", style: { boxShadow: '0 0 10px #0ff' } });
        const MagnetItemIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-blue-500 border-2 border-white", style: { boxShadow: '0 0 10px #00f' } });
        
        // --- END OF MERGED constants.tsx ---

        // --- START OF MERGED App.tsx ---

        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        const useGameLoop = (callback, isRunning) => {
            const animationFrameId = useRef();
            const lastTime = useRef(performance.now());
            const loop = useCallback((time) => { const deltaTime = (time - lastTime.current) / 1000; lastTime.current = time; callback(deltaTime); animationFrameId.current = requestAnimationFrame(loop); }, [callback]);
            useEffect(() => { if (isRunning) { lastTime.current = performance.now(); animationFrameId.current = requestAnimationFrame(loop); } return () => { if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current); }; }, [isRunning, loop]);
        };

        const App = () => {
            const [playerData, setPlayerData] = useState(null);
            const [selectedCharId, setSelectedCharId] = useState('char1');
            const [selectedPetId, setSelectedPetId] = useState('pet1');
            const [activeOverlay, setActiveOverlay] = useState(null);
            const [hitFlash, setHitFlash] = useState(false);
            const [scale, setScale] = useState(1);
            
            const [gameState, setGameState] = useState({ status: 'menu', score: 0, distance: 0, gameSpeed: INITIAL_GAME_SPEED, isFeverTime: false, feverGauge: 0, feverTimeLeft: 0, isPaused: false, isLastDash: false, lastDashTimeLeft: 0 });
            
            const playerStateRef = useRef(null);
            const gameObjectsRef = useRef([]);
            const nextSpawnDistanceRef = useRef(0);
            const petSkillTimerRef = useRef({ health_potion: 0, shield_item: 0 });
            const inGameStatsRef = useRef({ jellies: 0, distance: 0, obstaclesDestroyed: 0, jumps: 0, fevers: 0, itemsUsed: 0, currentRunScore: 0 });
            const reviveUsedRef = useRef(false);
            const [, forceUpdate] = useState({});

            const activePartnerBonus = useMemo(() => { if (!playerData) return null; const comboKey = `${selectedCharId}_${selectedPetId}`; return PARTNER_BONUSES[comboKey] || null; }, [selectedCharId, selectedPetId, playerData]);
            
            useEffect(() => {
                const handleResize = () => { const newScale = Math.min(window.innerWidth / WORLD_WIDTH, window.innerHeight / WORLD_HEIGHT); setScale(newScale); };
                window.addEventListener('resize', handleResize);
                handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            useEffect(() => {
                try {
                    const savedData = localStorage.getItem('ipkoDashDataV1');
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        if (!parsedData.missions) parsedData.missions = {};
                        if (!parsedData.treasures) parsedData.treasures = [];
                        if (!parsedData.equippedTreasures) parsedData.equippedTreasures = [];
                        if (!parsedData.enhancements) parsedData.enhancements = { health: 0, jelly_score: 0, fever_duration: 0, currency_gain: 0 };
                        setPlayerData(parsedData);
                    } else {
                        const initialData = { characters: { 'char1': { level: 1 } }, pets: { 'pet1': { level: 1 }, 'pet2': { level: 1 }, 'pet3': { level: 1 }, 'pet7': {level: 1} }, currency: 1000, highScore: 0, missions: {}, treasures: [], equippedTreasures: [], treasureChests: 1, enhancements: { health: 0, jelly_score: 0, fever_duration: 0, currency_gain: 0 } };
                        setPlayerData(initialData);
                    }
                } catch (error) { console.error("Failed to load player data:", error); }
            }, []);

            useEffect(() => { if (playerData) { try { localStorage.setItem('ipkoDashDataV1', JSON.stringify(playerData)); } catch (error) { console.error("Failed to save player data:", error); } } }, [playerData]);
            
            const getTreasureValue = useCallback((type) => {
                if (!playerData?.equippedTreasures) return 0;
                return playerData.equippedTreasures.map(id => TREASURES[id]).filter(t => t && t.type === type).reduce((sum, t) => sum + t.value, 0);
            }, [playerData?.equippedTreasures]);

            const startGame = () => {
                const character = CHARACTERS[selectedCharId];
                const charLevel = playerData.characters[selectedCharId]?.level || 1;
                const enhancementBonus = (playerData.enhancements.health || 0) * ENHANCEMENTS.health.baseValue;
                let maxHealth = getCharacterStat(character, charLevel) + getTreasureValue('health_bonus') + enhancementBonus;
                if (activePartnerBonus?.type === 'max_health_bonus') maxHealth += activePartnerBonus.value;
                let baseSpeed = INITIAL_GAME_SPEED * (1 + getTreasureValue('speed_boost'));
                if (character.skill === 'high_speed') baseSpeed *= 1.2;
                playerStateRef.current = { pos: { x: PLAYER_X_POSITION, y: WORLD_HEIGHT - GROUND_HEIGHT - PLAYER_RUN_SIZE.y }, size: PLAYER_RUN_SIZE, vy: 0, health: maxHealth, maxHealth: maxHealth, isJumping: false, jumpCount: 0, isSliding: false, hasShield: false, isGiant: false, isBlasting: false, hasMagnet: false, activeEffects: {} };
                if (character.skill === 'start_magnet') { playerStateRef.current.activeEffects['magnet'] = 5; }
                gameObjectsRef.current = [];
                nextSpawnDistanceRef.current = 0;
                petSkillTimerRef.current = { health_potion: 0, shield_item: 0 };
                inGameStatsRef.current = { jellies: 0, distance: 0, obstaclesDestroyed: 0, jumps: 0, fevers: 0, itemsUsed: 0, currentRunScore: 0 };
                reviveUsedRef.current = false;
                setGameState({ status: 'playing', score: 0, distance: 0, gameSpeed: baseSpeed, isFeverTime: false, feverGauge: 0, feverTimeLeft: 0, isPaused: false, isLastDash: false, lastDashTimeLeft: 0 });
            };

            const updateMissions = (stats) => {
                setPlayerData(prev => {
                    const newData = JSON.parse(JSON.stringify(prev));
                    let changed = false;
                    MISSIONS.forEach(mission => {
                        const missionProgress = newData.missions[mission.id] || { progress: 0, completed: false };
                        if (missionProgress.completed) return;
                        let progressToAdd = 0;
                        switch(mission.type) {
                            case 'collect_jellies': progressToAdd = stats.jellies; break; case 'run_distance': progressToAdd = stats.distance; break; case 'destroy_obstacles': progressToAdd = stats.obstaclesDestroyed; break; case 'jump_count': progressToAdd = stats.jumps; break; case 'fever_count': progressToAdd = stats.fevers; break; case 'use_items': progressToAdd = stats.itemsUsed; break; case 'single_run_score': if(stats.currentRunScore > missionProgress.progress) { missionProgress.progress = stats.currentRunScore; } break; case 'total_score': progressToAdd = stats.currentRunScore; break;
                        }
                        if(progressToAdd > 0) missionProgress.progress += progressToAdd;
                        if (missionProgress.progress >= mission.target) { missionProgress.completed = true; }
                        newData.missions[mission.id] = missionProgress;
                        changed = true;
                    });
                    return changed ? newData : prev;
                });
            };

            const triggerGameOver = () => {
                updateMissions(inGameStatsRef.current);
                setPlayerData(prev => {
                    if (!prev) return null;
                    const newHighScore = Math.max(prev.highScore, gameState.score);
                    let petBonus = PETS[selectedPetId].skill === 'currency_boost' ? (1 + getPetStat(PETS[selectedPetId], prev.pets[selectedPetId]?.level || 1, false) / 100) : 1;
                    if(activePartnerBonus?.type === 'currency_bonus_final') petBonus += activePartnerBonus.value;
                    const enhancementBonus = 1 + (prev.enhancements.currency_gain || 0) * ENHANCEMENTS.currency_gain.baseValue;
                    const earnedCurrency = Math.floor(gameState.score / 10 * petBonus * enhancementBonus);
                    return { ...prev, highScore: newHighScore, currency: Math.floor(prev.currency + earnedCurrency) };
                });
                setGameState(prev => ({ ...prev, status: 'gameOver' }));
            };

            const startLastDash = () => {
                const pet = PETS[selectedPetId];
                if (pet.skill === 'revive' && !reviveUsedRef.current) {
                    reviveUsedRef.current = true;
                    let reviveHealth = 0.25;
                    if(activePartnerBonus?.type === 'revive_health_bonus') reviveHealth = activePartnerBonus.value;
                    playerStateRef.current.health = playerStateRef.current.maxHealth * reviveHealth;
                    return;
                }
                if (!gameState.isLastDash) {
                    let duration = LAST_DASH_DURATION;
                    if(CHARACTERS[selectedCharId].skill === 'last_dash_boost') duration *= 1.5;
                    setGameState(prev => ({...prev, isLastDash: true, lastDashTimeLeft: duration}));
                }
            };

            const togglePause = () => { setGameState(prev => ({ ...prev, isPaused: !prev.isPaused })); };

            const spawnGameObject = useCallback(() => {
                const pattern = Math.random(); const newObjects = []; const basePos = { x: WORLD_WIDTH + 100, y: 0 }; const jellySize = {x: 20, y: 20}; const jellyY = WORLD_HEIGHT - GROUND_HEIGHT - jellySize.y - 10;
                if (Math.random() < 0.015) { newObjects.push({ id: Math.random(), type: 'rainbow_bear_jelly', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - 150 }, size: { x: 60, y: 80 }, Icon: RainbowBearJellyIcon }); } 
                else {
                    const character = CHARACTERS[selectedCharId]; let itemRoll = Math.random(); if (character.skill === 'item_boost') itemRoll *= 0.7;
                    if(itemRoll < 0.15) { 
                        const itemTypeRoll = Math.random(); let itemType = 'giant_potion'; let ItemIcon = GiantPotionIcon;
                        if(itemTypeRoll < 0.25) { itemType = 'blast_jelly'; ItemIcon = BlastJellyIcon; } else if(itemTypeRoll < 0.5) { itemType = 'shield_item'; ItemIcon = ShieldItemIcon; } else if(itemTypeRoll < 0.75) { itemType = 'magnet_item'; ItemIcon = MagnetItemIcon; }
                        newObjects.push({ id: Math.random(), type: itemType, pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - 120 }, size: {x: 40, y: 40}, Icon: ItemIcon });
                    } else {
                        if (pattern < 0.15) { const size = { x: 60, y: 50 }; newObjects.push({ id: Math.random(), type: 'obstacle_low', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleLowIcon }); }
                        else if (pattern < 0.25) { const size = { x: 80, y: 120 }; newObjects.push({ id: Math.random(), type: 'obstacle_high', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleHighIcon }); }
                        else if (pattern < 0.35) { const size = { x: 120, y: 40 }; newObjects.push({ id: Math.random(), type: 'obstacle_spikes', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleSpikesIcon }); }
                        else if (pattern < 0.45) { const size = { x: 50, y: 50 }; newObjects.push({ id: Math.random(), type: 'obstacle_falling', pos: { x: basePos.x + Math.random() * 100, y: -size.y }, size, Icon: ObstacleFallingIcon, vy: 0 }); }
                        else if (pattern < 0.6) { for (let i = 0; i < 8; i++) { const yOffset = Math.sin(i * 0.8) * 40; newObjects.push({ id: Math.random(), type: 'jelly', pos: { x: basePos.x + i * 50, y: jellyY + yOffset - 40 }, size: jellySize, Icon: JellyIcon }); } }
                        else if (pattern < 0.8) { const size = { x: 60, y: 50 }; newObjects.push({ id: Math.random(), type: 'obstacle_low', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleLowIcon }); for (let i = 0; i < 3; i++) newObjects.push({ id: Math.random(), type: 'jelly', pos: { x: basePos.x - 10 + i * 40, y: WORLD_HEIGHT - GROUND_HEIGHT - 120 }, size: jellySize, Icon: JellyIcon }); }
                        else { for (let i = 0; i < 3; i++) { const size = { x: 40, y: 40 }; newObjects.push({ id: Math.random(), type: 'obstacle_low', pos: { x: basePos.x + i * 150, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleLowIcon }); } }
                    }
                }
                gameObjectsRef.current.push(...newObjects); nextSpawnDistanceRef.current = gameState.distance + Math.random() * 300 + 250;
            }, [gameState.distance, selectedCharId]);

            const gameLoop = useCallback((deltaTime) => {
                if (gameState.isPaused) return; const player = playerStateRef.current; if (!player) return; const character = CHARACTERS[selectedCharId]; let speedMultiplier = 1;
                if (player.isBlasting) speedMultiplier = BLAST_JELLY_SPEED_MULTIPLIER;
                else if (character.skill === 'time_slow' && player.health < player.maxHealth * 0.5) { let slowDurBonus = activePartnerBonus?.type === 'slow_duration_bonus' ? activePartnerBonus.value : 0; speedMultiplier = 0.8 * (1 - slowDurBonus); }
                let newGameSpeed, actualSpeed, newDistance, newScore, newFeverGauge;
                if(gameState.isLastDash) { let newLastDashTimeLeft = gameState.lastDashTimeLeft - deltaTime; if(newLastDashTimeLeft <= 0) { triggerGameOver(); return; } player.health = 0; setGameState(prev => ({...prev, lastDashTimeLeft: newLastDashTimeLeft})); }
                newGameSpeed = gameState.gameSpeed + GAME_SPEED_INCREASE_RATE * deltaTime; actualSpeed = newGameSpeed * speedMultiplier; newDistance = gameState.distance + actualSpeed * deltaTime; inGameStatsRef.current.distance += actualSpeed * deltaTime / 100; newScore = gameState.score; newFeverGauge = gameState.feverGauge;
                Object.keys(player.activeEffects).forEach(effect => { player.activeEffects[effect] -= deltaTime; if (player.activeEffects[effect] <= 0) { delete player.activeEffects[effect]; if(effect === 'giant') player.isGiant = false; if(effect === 'blast') player.isBlasting = false; if(effect === 'magnet') player.hasMagnet = false; } });
                player.vy -= GRAVITY * deltaTime; player.pos.y -= player.vy * deltaTime;
                if (player.pos.y > WORLD_HEIGHT - GROUND_HEIGHT - player.size.y) { player.pos.y = WORLD_HEIGHT - GROUND_HEIGHT - player.size.y; player.vy = 0; if(player.isJumping) inGameStatsRef.current.jumps++; player.isJumping = false; player.jumpCount = 0; }
                let healthDecayMod = 1; if(activePartnerBonus?.type === 'health_decay_reduction') healthDecayMod = 1 - activePartnerBonus.value; if (!gameState.isFeverTime && !gameState.isLastDash) { player.health -= HEALTH_DECAY_RATE * (newGameSpeed / INITIAL_GAME_SPEED) * deltaTime * healthDecayMod; }
                let newFeverTimeLeft = gameState.feverTimeLeft; if (gameState.isFeverTime) { newFeverTimeLeft -= deltaTime; if (newFeverTimeLeft <= 0) { setGameState(prev => ({...prev, isFeverTime: false})); newFeverTimeLeft = 0; } }
                const pet = PETS[selectedPetId]; const petLevel = playerData.pets[selectedPetId]?.level || 1; const isSynergy = CHARACTERS[selectedCharId].skill === 'pet_boost'; const petStat = getPetStat(pet, petLevel, isSynergy); let cooldownReduction = activePartnerBonus?.type === 'pet_cooldown_reduction' ? 1 - activePartnerBonus.value : 1;
                if (pet.skill === 'health_potion' || pet.skill === 'shield_item') { petSkillTimerRef.current[pet.skill] += deltaTime; if (petSkillTimerRef.current[pet.skill] >= (petStat * cooldownReduction)) { petSkillTimerRef.current[pet.skill] = 0; const type = pet.skill === 'health_potion' ? 'health_potion_item' : 'shield_item'; const Icon = pet.skill === 'health_potion' ? HealthPotionIcon : ShieldItemIcon; gameObjectsRef.current.push({ id: Math.random(), type, pos: { x: WORLD_WIDTH + 50, y: WORLD_HEIGHT - GROUND_HEIGHT - 100 }, size: { x: 30, y: 30 }, Icon }); } }
                const playerRect = { x: player.pos.x, y: player.pos.y, width: player.size.x, height: player.size.y }; const playerCenter = { x: player.pos.x + player.size.x / 2, y: player.pos.y + player.size.y / 2 };
                gameObjectsRef.current = gameObjectsRef.current.filter(obj => {
                    if (player.activeEffects['magnet'] > 0 && (obj.type === 'jelly' || obj.type === 'big_jelly')) { const dist = Math.sqrt(Math.pow(obj.pos.x - playerCenter.x, 2) + Math.pow(obj.pos.y - playerCenter.y, 2)); if (dist < MAGNET_RADIUS) { obj.pos.x -= (obj.pos.x - playerCenter.x) * 0.1; obj.pos.y -= (obj.pos.y - playerCenter.y) * 0.1; } }
                    if (obj.type === 'obstacle_falling') { obj.vy = (obj.vy || 0) + GRAVITY * 0.3 * deltaTime; obj.pos.y += obj.vy * deltaTime; if (obj.pos.y > WORLD_HEIGHT) return false; }
                    obj.pos.x -= actualSpeed * deltaTime; if (obj.pos.x < -obj.size.x) return false;
                    const objRect = { x: obj.pos.x, y: obj.pos.y, width: obj.size.x, height: obj.size.y };
                    if (playerRect.x < objRect.x + objRect.width && playerRect.x + playerRect.width > objRect.x && playerRect.y < objRect.y + objRect.height && playerRect.y + playerRect.height > objRect.y) {
                        const handleJellyCollision = (isBig) => { inGameStatsRef.current.jellies++; const petScoreBonus = (PETS[selectedPetId].skill === 'score_bonus') ? getPetStat(PETS[selectedPetId], petLevel, isSynergy) : 0; const treasureScoreBonus = 1 + getTreasureValue('score_bonus'); const jellyScoreBonus = activePartnerBonus?.type === 'jelly_score_bonus' ? 1 + activePartnerBonus.value : 1; const treasureJellyPercentBonus = 1 + getTreasureValue('base_jelly_score_percentage_bonus'); const enhancementBonus = 1 + (playerData.enhancements.jelly_score || 0) * ENHANCEMENTS.jelly_score.baseValue; let baseJellyScore = isBig ? 50 : 10; if (activePartnerBonus?.type === 'base_jelly_score_bonus') baseJellyScore += activePartnerBonus.value; newScore += Math.floor((baseJellyScore + petScoreBonus) * treasureScoreBonus * jellyScoreBonus * treasureJellyPercentBonus * enhancementBonus); if (!gameState.isFeverTime) { const petFeverBonus = (PETS[selectedPetId].skill === 'fever_boost') ? getPetStat(PETS[selectedPetId], petLevel, isSynergy) : 0; newFeverGauge = Math.min(FEVER_GAUGE_MAX, newFeverGauge + FEVER_GAUGE_PER_JELLY + petFeverBonus); } return false; };
                        const handleItemCollision = (itemType) => { inGameStatsRef.current.itemsUsed++; let durationMultiplier = 1; if(PETS[selectedPetId].skill === 'item_duration_boost') durationMultiplier += PETS[selectedPetId].baseStat; if(activePartnerBonus?.type === 'all_item_duration_bonus') durationMultiplier += activePartnerBonus.value; switch(itemType) { case 'health_potion_item': player.health = Math.min(player.maxHealth, player.health + 20); break; case 'giant_potion': player.isGiant = true; player.activeEffects['giant'] = GIANT_POTION_DURATION * (1 + getTreasureValue('giant_duration')) * durationMultiplier; break; case 'blast_jelly': player.isBlasting = true; player.activeEffects['blast'] = BLAST_JELLY_DURATION * durationMultiplier; break; case 'shield_item': player.hasShield = true; break; case 'magnet_item': player.hasMagnet = true; let magnetBonus = activePartnerBonus?.type === 'magnet_duration_bonus' ? 1 + activePartnerBonus.value : 1; player.activeEffects['magnet'] = MAGNET_ITEM_DURATION * (1 + getTreasureValue('magnet_duration')) * durationMultiplier * magnetBonus; break; } return false; };
                        if (obj.type === 'rainbow_bear_jelly') { newScore += 1000; newFeverGauge = FEVER_GAUGE_MAX; gameObjectsRef.current.forEach(go => { if (go.type.startsWith('obstacle')) { go.type = 'big_jelly'; go.Icon = BigJellyIcon; go.size = {x: 30, y: 30}; } }); return false; }
                        if (obj.type.endsWith('_item') || obj.type.endsWith('_potion') || obj.type === 'blast_jelly') return handleItemCollision(obj.type); if (obj.type === 'jelly') return handleJellyCollision(false); if (obj.type === 'big_jelly') return handleJellyCollision(true);
                        if (obj.type.startsWith('obstacle')) {
                            if (gameState.isFeverTime || player.isGiant || player.isBlasting || gameState.isLastDash) {
                                inGameStatsRef.current.obstaclesDestroyed++;
                                newScore += FEVER_OBSTACLE_SCORE;
                                return false; // Obstacle destroyed
                            }
                            if (player.hasShield) {
                                player.hasShield = false; // Shield breaks
                                return true; // Obstacle persists
                            }
                            if (pet.skill === 'damage_negation') {
                                if (Math.random() * 100 < getPetStat(pet, petLevel, isSynergy)) {
                                    return false; // Lucky break, obstacle destroyed
                                }
                            }
                            player.health -= OBSTACLE_DAMAGE * deltaTime; // Continuous damage
                            setHitFlash(true);
                            setTimeout(() => setHitFlash(false), 150);
                            return true; // Obstacle persists
                        }
                    } return true;
                });
                inGameStatsRef.current.currentRunScore = newScore;
                let isFeverNow = gameState.isFeverTime; if (!isFeverNow && newFeverGauge >= FEVER_GAUGE_MAX) { isFeverNow = true; inGameStatsRef.current.fevers++; let feverDurBonus = activePartnerBonus?.type === 'fever_duration_bonus' ? 1 + activePartnerBonus.value : 1; const enhancementFeverBonus = (playerData.enhancements.fever_duration || 0) * ENHANCEMENTS.fever_duration.baseValue; newFeverTimeLeft = (FEVER_DURATION + enhancementFeverBonus) * (1 + getTreasureValue('fever_duration')) * feverDurBonus; newFeverGauge = 0; }
                if (newDistance > nextSpawnDistanceRef.current) spawnGameObject(); if (player.health <= 0 && !gameState.isLastDash) { startLastDash(); }
                setGameState(prev => ({ ...prev, score: Math.floor(newScore), distance: newDistance, gameSpeed: newGameSpeed, isFeverTime: isFeverNow, feverGauge: newFeverGauge, feverTimeLeft: newFeverTimeLeft }));
                forceUpdate({});
            }, [gameState, playerData, selectedCharId, selectedPetId, spawnGameObject, activePartnerBonus, getTreasureValue]);

            useGameLoop(gameLoop, gameState.status === 'playing' && !gameState.isPaused);

            const handleJump = useCallback(() => { if (gameState.isPaused) return; const player = playerStateRef.current; if (!player || player.jumpCount >= 2 || player.isSliding) return; player.vy = PLAYER_JUMP_FORCE * (1 + getTreasureValue('jump_boost')); player.isJumping = true; player.jumpCount++; }, [gameState.isPaused, getTreasureValue]);
            const handleJumpRelease = useCallback(() => { if (gameState.isPaused) return; const player = playerStateRef.current; if (!player || player.vy <= 0) return; player.vy *= 0.5; }, [gameState.isPaused]);
            const handleSlide = useCallback((isSliding) => { if (gameState.isPaused) return; const player = playerStateRef.current; if (!player || player.isJumping) return; player.isSliding = isSliding; const newSize = isSliding ? PLAYER_SLIDE_SIZE : PLAYER_RUN_SIZE; const oldY = player.pos.y + player.size.y; player.size = newSize; player.pos.y = oldY - newSize.y; }, [gameState.isPaused]);

            useEffect(() => {
                const onKeyDown = (e) => { if (gameState.status !== 'playing' || e.repeat) return; if(e.code === 'Escape') togglePause(); if(gameState.isPaused) return; if (e.code === 'Space' || e.code === 'ArrowUp') handleJump(); if (e.code === 'ArrowDown' || e.code === 'KeyS') handleSlide(true); };
                const onKeyUp = (e) => { if (gameState.status !== 'playing' || gameState.isPaused) return; if (e.code === 'Space' || e.code === 'ArrowUp') handleJumpRelease(); if (e.code === 'ArrowDown' || e.code === 'KeyS') handleSlide(false); };
                window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp); return () => { window.removeEventListener('keydown', onKeyDown); window.removeEventListener('keyup', onKeyUp); };
            }, [gameState.status, gameState.isPaused, handleJump, handleSlide, handleJumpRelease]);

            const costReduction = getTreasureValue('cost_reduction');
            const handleLevelUp = (type, id) => {
                setPlayerData(prev => { if (!prev) return null; const isChar = type === 'character'; const data = isChar ? prev.characters[id] : prev.pets[id]; const meta = isChar ? CHARACTERS[id] : PETS[id]; if (data.level >= meta.maxLevel) return prev; const cost = LEVEL_UP_COST(data.level, costReduction); if (prev.currency < cost) return prev; const newData = JSON.parse(JSON.stringify(prev)); newData.currency -= cost; (isChar ? newData.characters[id] : newData.pets[id]).level++; return newData; });
            };
            const handleUnlockCharacter = (charId) => {
                setPlayerData(prev => { const character = CHARACTERS[charId]; if (!prev || !character.unlockCost || prev.currency < character.unlockCost || prev.characters[charId]) return prev; const newData = JSON.parse(JSON.stringify(prev)); newData.currency -= character.unlockCost; newData.characters[charId] = { level: 1 }; return newData; });
            };
            const handleClaimMissionReward = (missionId) => {
                 setPlayerData(prev => { const mission = MISSIONS.find(m => m.id === missionId); const missionProgress = prev.missions[missionId]; if(!mission || !missionProgress || !missionProgress.completed || missionProgress.claimed) return prev; const newData = JSON.parse(JSON.stringify(prev)); newData.currency += mission.reward.currency; newData.treasureChests = (newData.treasureChests || 0) + mission.reward.treasureChests; newData.missions[missionId].claimed = true; return newData; });
            };
            const handleOpenTreasureChest = () => {
                setPlayerData(prev => { if(!prev || (prev.treasureChests || 0) < 1) return prev; const newData = JSON.parse(JSON.stringify(prev)); newData.treasureChests--; const unownedTreasures = Object.keys(TREASURES).filter(id => !newData.treasures.includes(id)); if(unownedTreasures.length > 0) { const newTreasureId = unownedTreasures[Math.floor(Math.random() * unownedTreasures.length)]; newData.treasures.push(newTreasureId); } else { newData.currency += 500; } return newData; });
            };
            const handleToggleEquipTreasure = (treasureId) => {
                setPlayerData(prev => { const newData = JSON.parse(JSON.stringify(prev)); const equipped = new Set(newData.equippedTreasures || []); if(equipped.has(treasureId)) { equipped.delete(treasureId); } else { if(equipped.size < 3) { equipped.add(treasureId); } } newData.equippedTreasures = Array.from(equipped); return newData; });
            };
            const handleUpgradeEnhancement = (id) => {
                setPlayerData(prev => { const currentLevel = prev.enhancements[id] || 0; const meta = ENHANCEMENTS[id]; if (currentLevel >= meta.maxLevel) return prev; const cost = ENHANCEMENT_COST(currentLevel, costReduction); if (prev.currency < cost) return prev; const newData = JSON.parse(JSON.stringify(prev)); newData.currency -= cost; newData.enhancements[id]++; return newData; });
            };

            if (!playerData) { return React.createElement('div', { className: "w-screen h-screen flex items-center justify-center text-white glowing-text" }, "Loading..."); }
            
            const renderMenu = () => {
                const SelectedCharacterIcon = CHARACTERS[selectedCharId].Icon;
                const SelectedPetIcon = PETS[selectedPetId].Icon;
                const character = CHARACTERS[selectedCharId];
                const pet = PETS[selectedPetId];
                const charLevel = playerData.characters[selectedCharId]?.level || 1;
                const petLevel = playerData.pets[selectedPetId]?.level || 1;

                const TopBar = () => (
                    React.createElement('header', { className: 'w-full p-4 flex justify-between items-center text-lg' },
                        React.createElement('div', { className: 'flex items-center gap-2 bg-black/30 px-3 py-1 rounded-full border border-gray-600' },
                            React.createElement('span', {className: 'text-yellow-400 font-bold'}, 'J'),
                            React.createElement('span', null, playerData.currency)
                        ),
                        React.createElement('div', { className: 'flex items-center gap-2 bg-black/30 px-3 py-1 rounded-full border border-gray-600' },
                           '📦',
                           React.createElement('span', null, playerData.treasureChests || 0)
                        )
                    )
                );

                const NavButton = ({ icon, label, onClick, active }) => (
                    React.createElement('button', { onClick, className: `nav-button ${active ? 'active' : ''}` },
                        React.createElement('div', { className: 'w-10 h-10 p-1' }, icon),
                        React.createElement('span', null, label)
                    )
                );

                return React.createElement('div', { className: 'w-full h-full flex flex-col text-white' },
                    React.createElement(TopBar, null),
                    React.createElement('main', { className: 'flex-grow flex flex-col items-center justify-center relative' },
                        React.createElement('h1', { className: 'absolute top-0 text-3xl font-black glowing-text' }, "잎코대쉬"),
                        React.createElement('div', { className: 'w-40 h-40', onClick: () => setActiveOverlay('team') }, React.createElement(SelectedCharacterIcon, null)),
                        React.createElement('div', { className: 'w-20 h-20 absolute bottom-[25%] right-[30%]', onClick: () => setActiveOverlay('team') }, React.createElement(SelectedPetIcon, null)),
                         activePartnerBonus && React.createElement('div', { className: "bg-purple-500/20 border border-purple-400 p-2 rounded-lg text-center absolute top-12" },
                            React.createElement('p', { className: "font-bold text-sm text-purple-300" }, `✨ 짝꿍 효과: ${activePartnerBonus.name} ✨`),
                            React.createElement('p', { className: "text-xs text-purple-200" }, activePartnerBonus.description)
                        )
                    ),
                    React.createElement('footer', { className: 'p-4 flex flex-col items-center gap-4' },
                        React.createElement('div', {className: 'text-center'},
                             React.createElement('h2', {className: 'text-xl font-bold'}, `${character.name} Lv.${charLevel}`),
                             React.createElement('h3', {className: 'text-md text-gray-400'}, `${pet.name} Lv.${petLevel}`),
                        ),
                        React.createElement('button', { onClick: startGame, className: "w-full py-4 text-xl font-black ui-button" }, "GAME START"),
                        React.createElement('div', { className: 'w-full flex justify-around p-2 bg-black/30 rounded-full border border-gray-700' },
                           React.createElement(NavButton, { label: '팀 편성', onClick: () => setActiveOverlay('team'), icon: '👥' }),
                           React.createElement(NavButton, { label: '강화', onClick: () => setActiveOverlay('enhancements'), icon: '🚀' }),
                           React.createElement(NavButton, { label: '미션', onClick: () => setActiveOverlay('missions'), icon: '🎯' }),
                           React.createElement(NavButton, { label: '보물', onClick: () => setActiveOverlay('treasures'), icon: '💎' })
                        )
                    )
                );
            };

            const renderOverlay = (title, children) => (
                 React.createElement('div', { className: 'main-overlay overlay-fade-in' },
                    React.createElement('header', { className: 'p-4 flex items-center justify-between border-b border-gray-700' },
                        React.createElement('div', null),
                        React.createElement('h2', { className: 'text-xl font-bold' }, title),
                        React.createElement('button', { onClick: () => setActiveOverlay(null), className: 'text-2xl font-bold' }, '×')
                    ),
                    React.createElement('div', { className: 'flex-grow p-4 overflow-y-auto' }, children)
                 )
            );

            const renderTeamSelection = () => {
                const renderList = (items, type) => (
                    React.createElement('div', { className: 'flex-1 overflow-y-auto' },
                        React.createElement('div', { className: 'grid grid-cols-2 gap-4' },
                            Object.values(items).map(item => {
                                const isChar = type === 'character';
                                const isUnlocked = isChar ? !!playerData.characters[item.id] : true; // Assuming all pets are unlocked by default
                                const isSelected = isChar ? selectedCharId === item.id : selectedPetId === item.id;
                                if (isUnlocked) {
                                    return React.createElement('div', { key: item.id, onClick: () => isChar ? setSelectedCharId(item.id) : setSelectedPetId(item.id), className: `selection-card p-2 text-center ${isSelected ? 'selected' : ''}` },
                                        React.createElement(item.Icon, { className: "w-16 h-16 mx-auto" }),
                                        React.createElement('p', { className: "font-bold mt-1 text-sm" }, item.name),
                                        React.createElement('p', { className: "text-xs" }, `Lv. ${(isChar ? playerData.characters[item.id] : playerData.pets[item.id])?.level || 1}`)
                                    );
                                }
                                const canAfford = item.unlockCost && playerData.currency >= item.unlockCost;
                                return React.createElement('div', { key: item.id, className: "selection-card p-2 text-center opacity-70" },
                                    React.createElement('div', { className: "relative w-16 h-16 mx-auto" },
                                        React.createElement(item.Icon, null),
                                        React.createElement('div', { className: 'absolute inset-0 bg-black/70 rounded-lg flex items-center justify-center' }, '🔒')
                                    ),
                                    React.createElement('p', { className: "font-bold mt-1 text-sm" }, item.name),
                                    React.createElement('button', { onClick: () => handleUnlockCharacter(item.id), disabled: !canAfford, className: "w-full mt-1 ui-button text-xs py-1" }, `${item.unlockCost} J`)
                                );
                            })
                        )
                    )
                );
                 return renderOverlay('팀 편성',
                    React.createElement('div', { className: 'flex h-full gap-4' },
                        renderList(CHARACTERS, 'character'),
                        renderList(PETS, 'pet')
                    )
                 );
            };

            const renderEnhancements = () => renderOverlay('영구 강화', 
                React.createElement('div', { className: 'flex flex-col gap-4' },
                    Object.keys(ENHANCEMENTS).map(id => {
                        const enhancement = ENHANCEMENTS[id]; const level = playerData.enhancements[id] || 0; const cost = ENHANCEMENT_COST(level, costReduction); const isMaxLevel = level >= enhancement.maxLevel;
                        return React.createElement('div', { key: id, className: "bg-black/30 p-3 rounded-lg border border-gray-700" },
                            React.createElement('div', { className: 'flex justify-between items-start' },
                                React.createElement('div', null,
                                    React.createElement('p', { className: 'font-bold' }, `${enhancement.name} (Lv.${level})`),
                                    React.createElement('p', { className: 'text-sm text-gray-400 mt-1' }, enhancement.description(level))
                                ),
                                React.createElement('button', { onClick: () => handleUpgradeEnhancement(id), disabled: isMaxLevel || playerData.currency < cost, className: "ui-button text-sm flex-shrink-0" }, isMaxLevel ? "MAX" : `${cost} J`)
                            )
                        );
                    })
                )
            );

            const renderMissions = () => renderOverlay('미션', 
                React.createElement('div', { className: 'flex flex-col gap-3' },
                    MISSIONS.map(mission => {
                        const progress = playerData.missions[mission.id] || { progress: 0, completed: false };
                        const isComplete = progress.completed; const canClaim = isComplete && !progress.claimed;
                        return React.createElement('div', { key: mission.id, className: `p-3 rounded-lg border ${canClaim ? 'border-yellow-400' : 'border-gray-700'} bg-black/30` },
                            React.createElement('p', { className: "font-bold" }, mission.description),
                            React.createElement('div', { className: "progress-bar-container mt-2" }, React.createElement('div', { className: "h-2 progress-bar", style: { width: `${Math.min(100, (progress.progress / mission.target) * 100)}%`, background: '#0ff' } })),
                            React.createElement('div', { className: "flex justify-between items-center mt-1" },
                                React.createElement('p', { className: "text-xs text-gray-400" }, `${Math.floor(progress.progress)} / ${mission.target}`),
                                canClaim ? React.createElement('button', { onClick: () => handleClaimMissionReward(mission.id), className: "ui-button text-xs py-1" }, '보상 받기') :
                                isComplete ? React.createElement('span', { className: "text-xs text-green-400" }, '완료') : null
                            )
                        );
                    })
                )
            );

            const renderTreasures = () => renderOverlay('보물', 
                React.createElement('div', null,
                    React.createElement('div', {className: "text-center mb-4 p-4 rounded-lg bg-black/30 border border-gray-700"}, 
                        React.createElement('p', {className: "text-2xl font-bold"}, "💎 보물 상자 💎"),
                        React.createElement('p', {className: "text-3xl font-bold text-yellow-300 my-2"}, `x ${playerData.treasureChests || 0}`),
                        React.createElement('button', { onClick: handleOpenTreasureChest, disabled: (playerData.treasureChests || 0) < 1, className: "ui-button" }, "1개 열기")
                    ),
                    React.createElement('h3', {className: 'font-bold text-lg mb-2'}, '보유 보물 (최대 3개 장착)'),
                    React.createElement('div', { className: 'grid grid-cols-2 gap-2' },
                        playerData.treasures.map(id => {
                            const treasure = TREASURES[id]; const isEquipped = playerData.equippedTreasures.includes(id);
                            return React.createElement('div', { key: id, onClick: () => handleToggleEquipTreasure(id), className: `p-3 text-center cursor-pointer rounded-lg border-2 ${isEquipped ? 'border-yellow-400 bg-yellow-500/20' : 'border-gray-600 bg-black/20'}` },
                                React.createElement('p', { className: "font-bold" }, treasure.name),
                                React.createElement('p', { className: "text-xs text-gray-400" }, treasure.description)
                            );
                        })
                    )
                )
            );
            
            const renderGame = () => {
                const player = playerStateRef.current; if (!player) return null;
                const CurrentCharacterIcon = CHARACTERS[selectedCharId].Icon;
                let playerClass = 'player-running'; if(player.isGiant) playerClass = 'player-giant'; else if (player.isJumping) playerClass = player.vy > 0 ? 'player-jumping' : 'player-falling';
                let playerTransform = ''; if(player.isBlasting) playerTransform = `translateX(${Math.random()*10 - 5}px)`;

                return React.createElement('div', { className: "relative w-full h-full overflow-hidden" },
                    hitFlash && React.createElement('div', { className: "hit-flash-overlay" }),
                    gameState.isLastDash && React.createElement('div', { className: "last-dash-overlay" }),
                    gameState.isFeverTime && React.createElement('div', { className: "fever-active-overlay" }),
                    React.createElement('div', { className: "absolute top-0 left-0", style: { width: WORLD_WIDTH, height: WORLD_HEIGHT } },
                        React.createElement('div', { className: `absolute ${playerClass}`, style: { left: player.pos.x, top: player.pos.y, width: player.size.x, height: player.size.y, transform: playerTransform, transition: 'width 0.1s, height 0.1s' } },
                           React.createElement(CurrentCharacterIcon, null),
                           player.hasShield && React.createElement('div', { className: 'shield-effect' })
                        ),
                        gameObjectsRef.current.map(obj => React.createElement('div', { key: obj.id, className: "absolute", style: { left: obj.pos.x, top: obj.pos.y, width: obj.size.x, height: obj.size.y } }, React.createElement(obj.Icon, null))),
                        React.createElement('div', { className: "absolute bottom-0 left-0 w-full bg-cyan-800", style: { height: GROUND_HEIGHT, boxShadow: '0 -10px 20px rgba(0, 255, 255, 0.5)' } })
                    ),
                    React.createElement('div', { className: "absolute top-2 left-4 right-4 text-white font-bold flex items-center gap-4" },
                        React.createElement('div', { className: 'text-2xl' }, `SCORE: ${gameState.score}`),
                        React.createElement('div', { className: 'flex-grow flex flex-col gap-1' },
                            React.createElement('div', { className: "progress-bar-container" }, React.createElement('div', { className: "h-3 progress-bar health-bar", style: { width: `${(player.health / player.maxHealth) * 100}%` } })),
                            React.createElement('div', { className: "progress-bar-container" }, React.createElement('div', { className: "h-2 progress-bar fever-bar", style: { width: `${(gameState.feverGauge / FEVER_GAUGE_MAX) * 100}%` } }))
                        ),
                         React.createElement('button', {onClick: togglePause, className: "w-10 h-10 p-1 flex-shrink-0"}, 
                          React.createElement('svg', { viewBox: "0 0 100 100", fill: "white" }, 
                            React.createElement('rect', { x: "25", y: "15", width: "15", height: "70", rx:"5" }),
                            React.createElement('rect', { x: "60", y: "15", width: "15", height: "70", rx:"5" })
                          )
                        )
                    ),
                    React.createElement('div', { className: "control-button left-4", onMouseDown: handleJump, onMouseUp: handleJumpRelease, onTouchStart: (e) => { e.preventDefault(); handleJump(); }, onTouchEnd: (e) => { e.preventDefault(); handleJumpRelease(); } }, React.createElement('span', { className: "text-5xl text-white/80" }, "↑")),
                    React.createElement('div', { className: "control-button right-4", onMouseDown: () => handleSlide(true), onMouseUp: () => handleSlide(false), onTouchStart: (e) => { e.preventDefault(); handleSlide(true); }, onTouchEnd: (e) => { e.preventDefault(); handleSlide(false); } }, React.createElement('span', { className: "text-5xl text-white/80" }, "↓"))
                );
            };

            const renderGameOver = () => React.createElement('div', { className: "main-overlay overlay-fade-in items-center justify-center p-4" },
                React.createElement('div', { className: "bg-slate-800/80 border-2 border-cyan-400 rounded-2xl p-8 text-center shadow-lg shadow-cyan-500/20 fade-in w-full max-w-md" },
                    React.createElement('h2', { className: "text-5xl font-black text-red-500 glowing-text" }, "GAME OVER"),
                    React.createElement('p', { className: "mt-4 text-2xl" }, "Final Score: ", React.createElement('span', { className: "text-cyan-300 font-bold" }, gameState.score)),
                    React.createElement('p', { className: "mt-2 text-xl" }, "High Score: ", React.createElement('span', { className: "text-yellow-300 font-bold" }, playerData.highScore)),
                    React.createElement('p', { className: "mt-2 text-xl" }, "Earned Jellies: ", React.createElement('span', { className: "text-yellow-300 font-bold" }, `+${Math.floor(gameState.score / 10)}`)),
                    React.createElement('button', { onClick: () => setGameState(prev => ({ ...prev, status: 'menu' })), className: "mt-8 px-8 py-3 ui-button" }, "메인 메뉴")
                )
            );

            const renderPauseMenu = () => React.createElement('div', { className: "main-overlay overlay-fade-in items-center justify-center p-4" },
                React.createElement('div', { className: "bg-slate-800/80 border-2 border-cyan-400 rounded-2xl p-8 text-center shadow-lg shadow-cyan-500/20 fade-in flex flex-col gap-4 w-full max-w-md" },
                    React.createElement('h2', { className: "text-5xl font-black text-white glowing-text" }, "PAUSED"),
                    React.createElement('button', { onClick: togglePause, className: "px-8 py-3 ui-button" }, "게임 재개"),
                    React.createElement('button', { onClick: () => setGameState(prev => ({ ...prev, status: 'menu' })), className: "px-8 py-3 ui-button" }, "메인 메뉴")
                )
            );
            
            return React.createElement('div', { className: "relative w-screen h-screen bg-black text-white flex items-center justify-center overflow-hidden font-sans antialiased select-none" },
                React.createElement('div', { className: "scrolling-background" }),
                 React.createElement('div', { className: "relative overflow-hidden bg-black/20", style: { width: WORLD_WIDTH, height: WORLD_HEIGHT, transform: `scale(${scale})`, transformOrigin: 'center center' } },
                    gameState.status === 'menu' && renderMenu(),
                    (gameState.status === 'playing' || gameState.status === 'gameOver') && renderGame(),
                    gameState.status === 'gameOver' && renderGameOver(),
                    gameState.isPaused && renderPauseMenu(),
                    activeOverlay === 'team' && renderTeamSelection(),
                    activeOverlay === 'enhancements' && renderEnhancements(),
                    activeOverlay === 'missions' && renderMissions(),
                    activeOverlay === 'treasures' && renderTreasures()
                )
            );
        };

        // --- END OF MERGED App.tsx ---

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(React.StrictMode, null, React.createElement(App, null)));
    </script>
  </body>
</html>