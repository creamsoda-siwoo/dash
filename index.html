<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><filter id='glow' x='-50%25' y='-50%25' width='200%25' height='200%25'><feGaussianBlur stdDeviation='4' result='blur'/><feMerge><feMergeNode in='blur'/><feMergeNode in='SourceGraphic'/></feMerge></filter></defs><rect width='100' height='100' rx='20' fill='%230c0a1e'/><text x='50' y='70' font-family='Arial, sans-serif' font-size='60' font-weight='bold' fill='%230ff' stroke='%23fff' stroke-width='1' text-anchor='middle' filter='url(%23glow)'>ID</text></svg>">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>잎코대쉬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
      :root {
        --glow-color: #0ff;
        --secondary-glow-color: #f0f;
        --danger-glow-color: #f00;
        --warn-glow-color: #ff0;
        --bg-color: #0c0a1e;
      }
      body {
        font-family: 'Noto Sans KR', sans-serif;
        background-color: var(--bg-color);
        overflow: hidden;
        touch-action: none;
      }
      @keyframes glow {
        0%, 100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--glow-color), 0 0 20px var(--glow-color); }
        50% { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px var(--glow-color), 0 0 40px var(--glow-color); }
      }
      .glowing-text {
        animation: glow 1.5s ease-in-out infinite;
      }
      @keyframes scroll-bg {
        0% { background-position: 0 0; }
        100% { background-position: -2000px 0; }
      }
       .scrolling-background {
          width: 100%;
          height: 100%;
          position: absolute;
          top: 0; left: 0;
          background: 
            radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
          z-index: -1;
          transition: filter 1s ease-in-out;
      }
      .scrolling-background::before, .scrolling-background::after {
          content: '';
          position: absolute;
          top: 0; left: 0;
          width: 100%; height: 100%;
          background-image: 
            url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><line x1="100" y1="0" x2="100" y2="200" stroke="rgba(0, 255, 255, 0.1)" stroke-width="1"/><line x1="0" y1="100" x2="200" y2="100" stroke="rgba(0, 255, 255, 0.1)" stroke-width="1"/></svg>'),
            url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50"><rect width="1" height="1" fill="rgba(255,255,255,0.2)"/></svg>');
          animation: scroll-bg 40s linear infinite;
      }
       .scrolling-background::after {
         animation-duration: 25s;
         opacity: 0.5;
       }
      @keyframes fade-in {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }
       @keyframes overlay-fade-in {
        from { opacity: 0; backdrop-filter: blur(0px); }
        to { opacity: 1; backdrop-filter: blur(5px); }
      }
      .fade-in { animation: fade-in 0.5s ease-out forwards; }
      .overlay-fade-in { animation: overlay-fade-in 0.3s ease-out forwards; }
      
      /* Player Animations */
      @keyframes run-cycle { 0%, 100% { transform: translateY(0) rotate(-2deg); } 50% { transform: translateY(-6px) rotate(2deg); } }
      .player-running { animation: run-cycle 0.4s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
      .player-jumping { transform: rotate(-10deg); }
      .player-falling { transform: rotate(10deg); }
      @keyframes giant-stomp { 0%, 100% { transform: translateY(0) scale(1.5); } 50% { transform: translateY(-10px) scale(1.5); } }
      .player-giant { animation: giant-stomp 0.5s ease-in-out infinite; }
      
      /* Boss Animations */
      @keyframes boss-idle { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
      @keyframes boss-enter { from { transform: translateX(200%); } to { transform: translateX(0); } }
      @keyframes raid-boss-idle { 0%, 100% { transform: scale(1) translateY(0); } 50% { transform: scale(1.02) translateY(-10px); } }
      
      /* Gacha Animations */
      @keyframes box-shake { 0%, 100% { transform: rotate(0); } 25% { transform: rotate(-5deg); } 75% { transform: rotate(5deg); } }
      @keyframes reveal-glow { from { opacity: 0; box-shadow: 0 0 0px 0px #fff; } to { opacity: 1; box-shadow: 0 0 100px 50px #fff; } }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

      /* Visual Effects */
      @keyframes hit-flash-anim { 0% { opacity: 0.5; } 100% { opacity: 0; } }
      .hit-flash-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: red; pointer-events: none; opacity: 0; animation: hit-flash-anim 0.2s ease-out; z-index: 100; }
      @keyframes last-dash-anim { 0%, 100% { box-shadow: inset 0 0 50px 20px rgba(255, 0, 0, 0.4); } 50% { box-shadow: inset 0 0 80px 30px rgba(255, 0, 0, 0.7); } }
      .last-dash-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; animation: last-dash-anim 0.5s ease-in-out infinite; z-index: 90; }
      @keyframes fever-glow { 0% { box-shadow: 0 0 20px 10px rgba(255, 235, 59, 0); } 50% { box-shadow: 0 0 40px 20px rgba(255, 235, 59, 0.4); } 100% { box-shadow: 0 0 20px 10px rgba(255, 235, 59, 0); } }
      .fever-active-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; animation: fever-glow 1s ease-in-out infinite; z-index: 10; }
      .shield-effect { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 120%; height: 120%; border: 4px solid #0ff; border-radius: 50%; box-shadow: 0 0 15px #0ff; opacity: 0.7; animation: glow 1.5s ease-in-out infinite alternate; }
      .shadow-form-effect { box-shadow: inset 0 0 20px 10px rgba(72, 61, 139, 0.8); filter: brightness(0.8) drop-shadow(0 0 10px #483d8b); }
      .obstacle-highlight { box-shadow: 0 0 20px 10px #ffdead; border: 2px solid #ffdead; border-radius: inherit; }
      .paladin-aura-effect {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 150%; height: 150%;
        border-radius: 50%; background: radial-gradient(circle, rgba(255,215,0,0.4) 0%, rgba(255,215,0,0) 70%);
        animation: glow 1s ease-in-out infinite alternate;
      }
      
      /* New Mobile UI Elements */
      .ui-button {
        background-color: rgba(0, 255, 255, 0.2);
        border: 2px solid var(--glow-color);
        border-radius: 12px;
        padding: 12px 24px;
        color: white;
        font-weight: bold;
        text-shadow: 0 0 5px var(--glow-color);
        transition: all 0.2s ease;
        -webkit-tap-highlight-color: transparent;
      }
      .ui-button:hover, .ui-button:active {
        background-color: rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 15px var(--glow-color);
        transform: scale(1.05);
      }
       .ui-button:disabled {
        background-color: rgba(128, 128, 128, 0.2);
        border-color: #888;
        color: #888;
        text-shadow: none;
        box-shadow: none;
        cursor: not-allowed;
        transform: scale(1);
      }
       .transcend-button {
        background-color: rgba(138, 43, 226, 0.4);
        border: 2px solid #9370DB;
        box-shadow: 0 0 15px #9370DB;
       }
       .transcend-button:hover, .transcend-button:active {
        background-color: rgba(138, 43, 226, 0.6);
        transform: scale(1.05);
       }
       .raid-button {
        background-color: rgba(255, 0, 0, 0.4);
        border-color: var(--danger-glow-color);
        box-shadow: 0 0 15px var(--danger-glow-color);
       }
       .raid-button:hover, .raid-button:active {
        background-color: rgba(255, 0, 0, 0.6);
       }
      .selection-card {
        border: 2px solid #555;
        background: rgba(255,255,255,0.05);
        border-radius: 12px;
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .selection-card.selected {
        border-color: var(--glow-color);
        box-shadow: 0 0 15px var(--glow-color);
        transform: scale(1.05);
      }
      .progress-bar-container {
        background-color: rgba(0,0,0,0.5);
        border-radius: 9999px;
        padding: 2px;
        border: 1px solid #555;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        border-radius: 9999px;
        transition: width 0.3s ease;
      }
      .health-bar { background: linear-gradient(90deg, #ff4d4d, #a3ff4d); }
      .fever-bar { background: linear-gradient(90deg, #ff9800, #ffeb3b); box-shadow: 0 0 10px #ffeb3b; }
      .boss-health-bar { background: linear-gradient(90deg, #f0f, #9400D3); }

      .control-button {
        position: absolute;
        bottom: 5vh;
        width: 16vh;
        height: 16vh;
        max-width: 100px;
        max-height: 100px;
        background-color: rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        transition: all 0.1s ease-out;
      }
      .control-button:active {
        background-color: rgba(0, 255, 255, 0.4);
        border-color: var(--glow-color);
        transform: scale(1.1);
      }
       .skill-button {
         position: absolute;
         bottom: 24vh;
         right: 4vw;
         width: 14vh;
         height: 14vh;
         max-width: 90px;
         max-height: 90px;
         background-color: rgba(138, 43, 226, 0.3);
         border: 2px solid #9370DB;
         box-shadow: 0 0 10px #9370DB;
       }
       .skill-button .cooldown-overlay {
         position: absolute;
         inset: 0;
         background: rgba(0,0,0,0.7);
         border-radius: 50%;
         display: flex;
         align-items: center;
         justify-content: center;
         font-size: 2em;
         font-weight: bold;
         color: white;
       }
      
      .nav-button {
        background: none;
        border: none;
        color: #888;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        font-size: 12px;
        font-weight: bold;
        transition: color 0.2s ease, text-shadow 0.2s ease;
      }
      .nav-button:hover, .nav-button.active {
        color: var(--glow-color);
        text-shadow: 0 0 8px var(--glow-color);
      }
      .main-overlay {
        position: absolute;
        inset: 0;
        z-index: 50;
        background: rgba(12, 10, 30, 0.8);
        backdrop-filter: blur(5px);
        display: flex;
        flex-direction: column;
      }
       .tab-button {
        flex: 1; padding: 8px 12px; border: none; background: none; color: #888; font-weight: bold; border-bottom: 2px solid transparent; transition: all 0.2s ease;
      }
       .tab-button.active {
        color: var(--glow-color); border-bottom-color: var(--glow-color);
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react": "https://esm.sh/react@18.2.0"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script type="module">
        import React from 'react';
        import ReactDOM from 'react-dom/client';

        // --- START OF COMBINED GAME CODE ---

        // --- START OF MERGED types.ts ---
        const IVector2D = {}; const CharacterSkill = {}; const PetSkill = {}; const TreasureType = {}; const MissionType = {}; const RewardType = {}; const PartnerBonusType = {}; const GameObjectType = {}; const GameStatus = {};
        // --- END OF MERGED types.ts ---

        // --- START OF MERGED constants.tsx ---

        const WORLD_WIDTH = 1280; const WORLD_HEIGHT = 720; const GROUND_HEIGHT = 60; const GRAVITY = 3000; const PLAYER_X_POSITION = 150;
        const PLAYER_JUMP_FORCE = 1100; const PLAYER_RUN_SIZE = { x: 50, y: 70 }; const PLAYER_SLIDE_SIZE = { x: 70, y: 40 };
        const INITIAL_MAX_HEALTH = 100; const HEALTH_DECAY_RATE = 2.0; const OBSTACLE_DAMAGE = 45; // Damage per second, was 60
        const INITIAL_GAME_SPEED = 400; const GAME_SPEED_INCREASE_RATE = 4;
        const FEVER_GAUGE_MAX = 100; const FEVER_GAUGE_PER_JELLY = 5; const FEVER_DURATION = 8; const FEVER_OBSTACLE_SCORE = 100;
        const LAST_DASH_DURATION = 3;
        const GIANT_POTION_DURATION = 8; const BLAST_JELLY_DURATION = 1.5; const BLAST_JELLY_SPEED_MULTIPLIER = 2.5; const MAGNET_ITEM_DURATION = 10; const MAGNET_RADIUS = 250;
        const BOSS_APPEARANCE_DISTANCE = 4000; const BOSS_MAX_HEALTH = 2500;
        const GUILD_RAID_BOSS_MAX_HEALTH = 5000000;

        const SvgIconWrapper = ({ children, color, filterId, className }) => (
            React.createElement('svg', { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", className: className || "w-full h-full", style: { filter: `url(#${filterId})` } },
                React.createElement('defs', null, React.createElement('filter', { id: filterId, x:"-50%", y:"-50%", width:"200%", height:"200%" },
                    React.createElement('feDropShadow', { dx: "0", dy: "0", stdDeviation: "5", floodColor: color }),
                    React.createElement('feDropShadow', { dx: "0", dy: "0", stdDeviation: "8", floodColor: color })
                )),
                children
            )
        );

        const CHARACTERS = {
            'char1': { id: 'char1', name: '네온 스트라이커', description: '기본에 충실한 밸런스형 런너입니다.', skill: 'none', maxLevel: 10, baseStat: 100, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#0ff", filterId: "char1-glow", className: className }, React.createElement('rect', { x: "25", y: "30", width: "50", height: "70", rx: "10", fill: "#0ff", stroke: "#fff", strokeWidth: "5" }), React.createElement('circle', { cx: "50", cy: "30", r: "20", fill: "#0ff", stroke: "#fff", strokeWidth: "5" })) },
            'char2': { id: 'char2', name: '마젠타 팬텀', description: '더 높은 체력을 가지고 오래 버팁니다.', skill: 'extra_health', maxLevel: 10, baseStat: 120, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#f0f", filterId: "char2-glow", className: className }, React.createElement('polygon', { points: "50,10 90,90 10,90", fill: "#f0f", stroke: "#fff", strokeWidth: "5" })) },
            'char3': { id: 'char3', name: '볼텍스', description: '게임 시작 시 자석 효과를 가지고 시작합니다.', skill: 'start_magnet', maxLevel: 10, baseStat: 90, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#9400D3", filterId: "char3-glow", className: className }, React.createElement('path', { d: "M50 10 C 90 10, 90 90, 50 90 S 10 90, 10 10 C 10 10, 50 10, 50 10 Z", transform: "rotate(45 50 50)", fill: "none", stroke: "#9400D3", strokeWidth: "6" }), React.createElement('circle', { cx: "50", cy: "50", r: "10", fill: "#fff" })) },
            'char4': { id: 'char4', name: '크로노', description: '체력이 50% 이하가 되면 게임 속도가 느려집니다.', skill: 'time_slow', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#00fa9a", filterId: "char4-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "40", fill: "none", stroke: "#00fa9a", strokeWidth: "6", strokeDasharray: "10 5" }), React.createElement('path', { d: "M50 20 V50 H70", fill: "none", stroke: "#fff", strokeWidth: "6" })) },
            'char5': { id: 'char5', name: '블레이즈', description: '게임 속도가 더 빠르지만, 점수 보너스를 얻습니다.', skill: 'high_speed', maxLevel: 10, baseStat: 80, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff4500", filterId: "char5-glow", className: className }, React.createElement('path', { d: "M50 10 L60 40 L90 45 L65 65 L70 95 L50 80 L30 95 L35 65 L10 45 L40 40 Z", fill: "#ff4500", stroke: "#fff", strokeWidth: "4" })) },
            'char6': { id: 'char6', name: '클로버', description: '게임에 아이템이 더 자주 등장합니다.', skill: 'item_boost', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#32cd32", filterId: "char6-glow", className: className }, React.createElement('path', { d: "M50 25 C 30 5, 30 40, 50 50 C 70 40, 70 5, 50 25 Z", fill: "#32cd32" }), React.createElement('path', { d: "M75 50 C 95 30, 60 30, 50 50 C 60 70, 95 70, 75 50 Z", fill: "#32cd32" }), React.createElement('path', { d: "M50 75 C 30 95, 30 60, 50 50 C 70 60, 70 95, 50 75 Z", fill: "#32cd32" }), React.createElement('path', { d: "M25 50 C 5 30, 40 30, 50 50 C 40 70, 5 70, 25 50 Z", fill: "#32cd32" })) },
            'char7': { id: 'char7', name: '시너지', description: '장착한 펫의 능력이 20% 향상됩니다.', skill: 'pet_boost', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#fafad2", filterId: "char7-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "30", fill: "none", stroke: "#fafad2", strokeWidth: "6" }), React.createElement('circle', { cx: "50", cy: "50", r: "15", fill: "#fafad2" })) },
            'char8': { id: 'char8', name: '피닉스', description: '최후의 질주 시간이 50% 증가합니다.', skill: 'last_dash_boost', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff8c00", filterId: "char8-glow", className: className }, React.createElement('path', { d: "M20 80 Q 50 20, 80 80 Q 50 50, 20 80 Z", fill: "#ff8c00" }), React.createElement('path', { d: "M30 70 Q 50 30, 70 70 Q 50 55, 30 70 Z", fill: "#ff4500", stroke:"#fff", strokeWidth:"2" })) },
            'char9': { id: 'char9', name: '에코', description: '모든 아이템의 효과(회복량, 지속시간)가 2배가 됩니다.', skill: 'item_double_effect', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#00ced1", filterId: "char9-glow", className: className }, React.createElement('path', { d: "M50 20 A 30 30 0 0 1 50 80 A 30 30 0 0 1 50 20 M50 35 A 15 15 0 0 1 50 65 A 15 15 0 0 1 50 35", fill: "none", stroke: "#00ced1", strokeWidth: "6" }), React.createElement('circle', { cx: "50", cy: "50", r: "5", fill: "#fff" })) },
            'char10': { id: 'char10', name: '리프트', description: '슬라이드 중에는 장애물에 피해를 입지 않습니다.', skill: 'slide_invincible', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#7b68ee", filterId: "char10-glow", className: className }, React.createElement('path', { d: "M20 80 L50 20 L80 80 H20 Z", fill: "#7b68ee", stroke: "#fff", strokeWidth: "4", transform: "skewX(-10)" }), React.createElement('path', { d: "M30 80 L50 40 L70 80", fill: "none", stroke: "#fff", strokeWidth: "3", opacity: "0.7" })) },
            'char11': { id: 'char11', name: '글리치', description: '가끔씩 앞으로 순간이동하여 장애물을 통과합니다.', skill: 'random_teleport', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff00ff", filterId: "char11-glow", className: className }, React.createElement('text', { x: "50", y: "70", fontFamily: "monospace", fontSize: "60", textAnchor: "middle", fill: "#ff00ff", stroke:"#fff", strokeWidth: "2" }, "ERR")) },
            'char12': { id: 'char12', name: '뱅커', description: '10초마다 현재 점수의 1%를 보너스로 얻습니다.', skill: 'interest_score', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#00ff7f", filterId: "char12-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "35", fill: "#00ff7f" }), React.createElement('text', { x: "50", y: "68", fontSize: "45", textAnchor: "middle", fill: "black", fontWeight: "bold" }, "$")) },
            'char13': { id: 'char13', name: '이지스', description: '보호막 파괴 시, 주변 장애물을 파괴합니다.', skill: 'shield_blast', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#1e90ff", filterId: "char13-glow", className: className }, React.createElement('path', { d: "M50 10 L90 30 L90 70 L50 90 L10 70 L10 30 Z", fill: "none", stroke: "#1e90ff", strokeWidth: "8" }), React.createElement('path', { d: "M50 10 L90 70 M10 70 L90 30", stroke: "#fff", strokeWidth: "4" })) },
            'char14': { id: 'char14', name: '리듬', description: '연속으로 5회 점프 시 추가 점수를 얻습니다.', skill: 'rhythm_bonus', maxLevel: 10, baseStat: 100, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff1493", filterId: "char14-glow", className: className }, React.createElement('path', { d: "M20 70 Q 35 40, 50 70 T 80 70", stroke: "#ff1493", strokeWidth: "6", fill: "none" }), React.createElement('path', { d: "M20 50 Q 35 20, 50 50 T 80 50", stroke: "#ff1493", strokeWidth: "6", fill: "none" })) },
            'char15': { id: 'char15', name: '게이저', description: '액티브 스킬: 전방으로 파괴적인 레이저를 발사합니다.', skill: 'laser_beam', cooldown: 8, maxLevel: 10, baseStat: 100, unlockCost: 5000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff6347", filterId: "char15-glow", className: className }, React.createElement('path', { d: "M50 20 L80 50 L50 80 L20 50 Z", fill: "#ff6347" }), React.createElement('circle', { cx: "50", cy: "50", r: "15", fill: "white" }), React.createElement('circle', { cx: "50", cy: "50", r: "8", fill: "red" })) },
            'char16': { id: 'char16', name: '레이븐', description: '액티브 스킬: 체력을 소모하여 그림자 형태가 됩니다. 그림자 형태에서는 무적이며 젤리 점수가 2배가 됩니다.', skill: 'shadow_pact', cooldown: 20, maxLevel: 10, baseStat: 100, unlockCost: 7500, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#483d8b", filterId: "char16-glow", className: className }, React.createElement('path', { d: "M50 10 C 30 30, 20 70, 50 90 C 80 70, 70 30, 50 10 Z", fill: "#483d8b" }), React.createElement('path', { d: "M50 20 C 40 35, 35 60, 50 80 C 65 60, 60 35, 50 20 Z", fill: "#000" })) },
            'char17': { id: 'char17', name: '팔라딘', description: '액티브 스킬: 보호 오라를 발동합니다. 오라 상태에서는 무적이며 통과한 장애물마다 피버 게이지를 획득합니다.', skill: 'protective_aura', cooldown: 25, maxLevel: 10, baseStat: 100, guildShop: true, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ffd700", filterId: "char17-glow", className: className }, React.createElement('path', { d: "M50 10 L90 30 V70 L50 90 L10 70 V30 Z", fill: "#fff" }), React.createElement('path', { d: "M50 20 L75 35 V65 L50 80 L25 65 V35 Z", fill: "#ffd700" }), React.createElement('path', { d: "M50 30 L65 40 V60 L50 70 L35 60 V40 Z", fill: "#fff" })) },
        };

        const PETS = {
            'pet1': { id: 'pet1', name: '큐브', description: '일정 시간마다 체력 포션을 생성합니다.', skill: 'health_potion', maxLevel: 10, baseStat: 20, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#fff", filterId: "pet1-glow", className: className }, React.createElement('rect', { x: "20", y: "20", width: "60", height: "60", rx: "10", fill: "#fff", stroke: "#000", strokeWidth: "5", transform: "rotate(45 50 50)" })) },
            'pet2': { id: 'pet2', name: '윙키', description: '젤리 획득 시 추가 점수를 줍니다.', skill: 'score_bonus', maxLevel: 10, baseStat: 1, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ff0", filterId: "pet2-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "30", fill: "#ff0" }), React.createElement('path', { d: "M 35,40 Q 50,60 65,40", stroke: "black", strokeWidth: "5", fill: "none" })) },
            'pet3': { id: 'pet3', name: '실드론', description: '일정 시간마다 보호막 아이템을 생성합니다.', skill: 'shield_item', maxLevel: 10, baseStat: 30, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#40E0D0", filterId: "pet3-glow", className: className }, React.createElement('path', { d: "M50 10 L90 30 L90 70 L50 90 L10 70 L10 30 Z", fill: "#40E0D0", stroke: "#fff", strokeWidth: "5" }), React.createElement('path', { d: "M50 25 L75 40 L75 60 L50 75 L25 60 L25 40 Z", fill: "none", stroke: "#fff", strokeWidth: "5" })) },
            'pet4': { id: 'pet4', name: '스파크', description: '젤리 획득 시 피버 게이지를 추가로 채웁니다.', skill: 'fever_boost', maxLevel: 10, baseStat: 1, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ffa500", filterId: "pet4-glow", className: className }, React.createElement('path', { d: "M50 10 L40 45 H60 L50 90 L60 55 H40 Z", fill: "#ffa500", stroke: "#fff", strokeWidth: "4" })) },
            'pet5': { id: 'pet5', name: '제트', description: '체력이 0이 되면, 한 번 부활합니다 (체력 25%).', skill: 'revive', maxLevel: 1, baseStat: 1, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#b0c4de", filterId: "pet5-glow", className: className }, React.createElement('path', { d: "M50 20 L70 40 L60 45 L80 65 L50 90 L20 65 L40 45 L30 40 Z", fill: "#b0c4de", stroke: "#fff", strokeWidth: "4" })) },
            'pet6': { id: 'pet6', name: '마이더스', description: '게임 종료 시 획득하는 젤리가 증가합니다.', skill: 'currency_boost', maxLevel: 10, baseStat: 5, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ffd700", filterId: "pet6-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "35", fill: "#ffd700", stroke: "#fff", strokeWidth: "4" }), React.createElement('text', { x: "50", y: "65", fontSize: "40", textAnchor: "middle", fill: "black", fontWeight: "bold" }, "J")) },
            'pet7': { id: 'pet7', name: '수호령', description: '5% 확률로 장애물 피해를 무시합니다.', skill: 'damage_negation', maxLevel: 10, baseStat: 5, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#add8e6", filterId: "pet7-glow", className: className }, React.createElement('path', { d: "M50 20 C 30 40, 30 70, 50 80 C 70 70, 70 40, 50 20 Z", fill: "#add8e6", opacity:"0.7" }), React.createElement('circle', { cx: "50", cy: "50", r: "5", fill: "#fff" })) },
            'pet8': { id: 'pet8', name: '듀라', description: '모든 아이템의 지속 시간이 25% 증가합니다.', skill: 'item_duration_boost', maxLevel: 1, baseStat: 0.25, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#cd853f", filterId: "pet8-glow", className: className }, React.createElement('path', { d: "M30 20 H70 L60 50 L70 80 H30 L40 50 Z", fill: "#cd853f", stroke: "#fff", strokeWidth: "4" })) },
            'pet9': { id: 'pet9', name: '옵저버', description: '게임 종료 후, 미션 진행도가 10% 추가됩니다.', skill: 'mission_progress_boost', maxLevel: 1, baseStat: 0.1, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#4682b4", filterId: "pet9-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "35", fill: "#4682b4" }), React.createElement('circle', { cx: "50", cy: "50", r: "20", fill: "#fff" }), React.createElement('circle', { cx: "50", cy: "50", r: "10", fill: "#000" })) },
            'pet10': { id: 'pet10', name: '골디', description: '일정 시간마다 보너스 젤리(큰 젤리)를 생성합니다.', skill: 'generate_bonus_jelly', maxLevel: 10, baseStat: 25, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#daa520", filterId: "pet10-glow", className: className }, React.createElement('rect', { x: "25", y: "35", width: "50", height: "30", rx: "5", fill: "#daa520", stroke: "#fff", strokeWidth: "4" }), React.createElement('circle', { cx: "50", cy: "50", r: "10", fill: "gold", stroke: "black", strokeWidth: "2" })) },
            'pet11': { id: 'pet11', name: '페이서', description: '게임 속도 증가율이 15% 감소합니다.', skill: 'pace_keeper', maxLevel: 1, baseStat: 0.15, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#87ceeb", filterId: "pet11-glow", className: className }, React.createElement('path', { d: "M20 50 L40 30 L60 70 L80 50", stroke: "#87ceeb", strokeWidth: "6", fill: "none" })) },
            'pet12': { id: 'pet12', name: '미믹', description: '아이템 획득 시 20% 확률로 복제합니다.', skill: 'copy_item', maxLevel: 1, baseStat: 0.2, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ba55d3", filterId: "pet12-glow", className: className }, React.createElement('circle', { cx: "35", cy: "50", r: "20", fill: "#ba55d3" }), React.createElement('circle', { cx: "65", cy: "50", r: "20", fill: "#ba55d3", opacity: "0.7" })) },
            'pet13': { id: 'pet13', name: '블라스토이드', description: '젤리 50개를 모으면 작은 폭발을 일으킵니다.', skill: 'jelly_blast', maxLevel: 10, baseStat: 50, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#dc143c", filterId: "pet13-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "30", fill: "#dc143c" }), React.createElement('path', { d: "M50 20 L55 45 L80 50 L55 55 L50 80 L45 55 L20 50 L45 45 Z", fill: "yellow" })) },
            'pet14': { id: 'pet14', name: '스파키', description: '피버 게이지 30%를 가지고 시작합니다.', skill: 'fever_start_boost', maxLevel: 1, baseStat: 30, unlockCost: 1000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#f0e68c", filterId: "pet14-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "25", fill: "#f0e68c" }), React.createElement('path', { d: "M50 25 V75 M25 50 H75", stroke: "#fff", strokeWidth: "6" })) },
            'pet15': { id: 'pet15', name: '펄스', description: '액티브 스킬: 화면의 모든 장애물을 파괴합니다.', skill: 'emp_blast', cooldown: 15, maxLevel: 10, baseStat: 1, unlockCost: 5000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#00BFFF", filterId: "pet15-glow", className: className }, React.createElement('path', { d: "M50 20 A 30 30 0 0 1 50 80 A 30 30 0 0 1 50 20 M50 35 A 15 15 0 0 1 50 65 A 15 15 0 0 1 50 35", fill: "none", stroke: "#00BFFF", strokeWidth: "8" }), React.createElement('circle', { cx: "50", cy: "50", r: "5", fill: "white" })) },
            'pet16': { id: 'pet16', name: '오라클', description: '일정 시간마다 다음에 나타날 장애물을 미리 표시해줍니다.', skill: 'foresight', maxLevel: 10, baseStat: 15, unlockCost: 3000, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#ffdead", filterId: "pet16-glow", className: className }, React.createElement('circle', { cx: "50", cy: "50", r: "30", fill: "none", stroke: "#ffdead", strokeWidth: "6" }), React.createElement('circle', { cx: "50", cy: "30", r: "8", fill: "#fff" })) },
            'pet17': { id: 'pet17', name: '그리핀', description: '모든 파워업 아이템의 지속 시간이 20% 증가합니다.', skill: 'powerup_boost', maxLevel: 10, baseStat: 20, guildShop: true, Icon: ({ className }) => React.createElement(SvgIconWrapper, { color: "#f5deb3", filterId: "pet17-glow", className: className }, React.createElement('path', { d: "M20 80 L50 20 L80 80 M40 50 C 20 30, 80 30, 60 50", stroke: "#f5deb3", strokeWidth: "6", fill: "none" }), React.createElement('path', { d: "M30 20 C 50 0, 50 40, 70 20", stroke: "#fff", strokeWidth: "4", fill: "none" })) },
        };
        
        const PARTNER_BONUSES = {
            'char1_pet1': { name: '단단한 유대', description: '최대 체력 +15', type: 'max_health_bonus', value: 15 }, 'char2_pet2': { name: '황금 듀오', description: '젤리 획득 점수 +10%', type: 'jelly_score_bonus', value: 0.1 }, 'char5_pet4': { name: '타오르는 열정', description: '피버 지속 시간 +15%', type: 'fever_duration_bonus', value: 0.15 }, 'char7_pet3': { name: '완벽한 방어', description: '펫 스킬 쿨타임 -25%', type: 'pet_cooldown_reduction', value: 0.25 }, 'char8_pet5': { name: '불사조의 의지', description: '부활 시 체력 50%로 부활', type: 'revive_health_bonus', value: 0.5 }, 'char6_pet6': { name: '행운의 부자', description: '게임 종료 젤리 보너스 +10%', type: 'currency_bonus_final', value: 0.1 }, 'char3_pet7': { name: '자기장 강화', description: '자석 아이템 지속 시간 +30%', type: 'magnet_duration_bonus', value: 0.3 }, 'char4_pet8': { name: '시간의 지배자', description: '슬로우 효과 지속 시간 +20%', type: 'slow_duration_bonus', value: 0.2 }, 'char1_pet2': { name: '러너스 하이', description: '기본 젤리 점수 +5', type: 'base_jelly_score_bonus', value: 5 }, 'char2_pet1': { name: '꺼지지 않는 체력', description: '체력 자연 감소 속도 -15%', type: 'health_decay_reduction', value: 0.15 }, 'char7_pet8': { name: '아이템 마스터', description: '모든 아이템 지속 시간 +10%', type: 'all_item_duration_bonus', value: 0.1 }, 'char15_pet15': { name: '시스템 붕괴', description: '액티브 스킬 쿨타임 -10%', type: 'active_skill_cooldown_reduction', value: 0.1 },
            'char16_pet16': { name: '그림자 예언', description: '그림자 형태 지속시간 +1초', type: 'shadow_pact_duration_bonus', value: 1 },
            'char17_pet17': { name: '천상의 수호자', description: '액티브 스킬 오라 지속시간 +1초', type: 'protective_aura_duration_bonus', value: 1 },
        };

        const TREASURES = {
            'tr1': { id: 'tr1', name: '빛나는 깃털', description: '점프 높이 +5%', type: 'jump_boost', value: 0.05 }, 'tr2': { id: 'tr2', name: '견고한 심장', description: '최대 체력 +10', type: 'health_bonus', value: 10 }, 'tr3': { id: 'tr3', name: '질주의 부츠', description: '기본 속도 +5%', type: 'speed_boost', value: 0.05 }, 'tr4': { id: 'tr4', name: '황금 나침반', description: '획득 점수 +5%', type: 'score_bonus', value: 0.05 }, 'tr5': { id: 'tr5', name: '열정의 불꽃', description: '피버 시간 +10%', type: 'fever_duration', value: 0.1 }, 'tr6': { id: 'tr6', name: '황금 젤리', description: '젤리 점수 +10%', type: 'base_jelly_score_percentage_bonus', value: 0.1 }, 'tr7': { id: 'tr7', name: '자력의 돌', description: '자석 시간 +20%', type: 'magnet_duration', value: 0.2 }, 'tr8': { id: 'tr8', name: '거인의 물약', description: '거인화 시간 +20%', type: 'giant_duration', value: 0.2 }, 'tr9': { id: 'tr9', name: '절약의 동전', description: '비용 -5%', type: 'cost_reduction', value: 0.05 }, 'tr10': { id: 'tr10', name: '행운의 네잎클로버', description: '상자 행운 증가', type: 'luck_boost', value: 0.1 },
        };

        const TRANSCENDENCE_COST = (level) => 100 * Math.pow(2, level);
        const TRANSCENDENCE_BONUSES = {
            'char1': { 1: { name: '네온 쇼크웨이브', description: '10번째 점프마다 주변의 젤리를 파괴하는 충격파를 발생시킵니다.' } },
        };

        const MISSIONS = [
            { id: 'm1', description: '젤리 500개 수집', type: 'collect_jellies', target: 500, reward: { currency: 100, gachaChests: 0 } }, { id: 'm2', description: '1,000m 달리기', type: 'run_distance', target: 1000, reward: { currency: 100, gachaChests: 0 } }, { id: 'm3', description: '장애물 20개 파괴', type: 'destroy_obstacles', target: 20, reward: { currency: 150, gachaChests: 0 } }, { id: 'm4', description: '점프 100번 하기', type: 'jump_count', target: 100, reward: { currency: 100, gachaChests: 0 } }, { id: 'm5', description: '피버 타임 5번 발동', type: 'fever_count', target: 5, reward: { currency: 200, gachaChests: 1 } }, { id: 'm6', description: '한 게임에서 10,000점 달성', type: 'single_run_score', target: 10000, reward: { currency: 250, gachaChests: 0 } }, { id: 'm7', description: '젤리 2,500개 수집', type: 'collect_jellies', target: 2500, reward: { currency: 300, gachaChests: 0 } }, { id: 'm8', description: '5,000m 달리기', type: 'run_distance', target: 5000, reward: { currency: 300, gachaChests: 0 } }, { id: 'm9', description: '아이템 25개 사용', type: 'use_items', target: 25, reward: { currency: 200, gachaChests: 0 } }, { id: 'm10', description: '총 50,000점 누적', type: 'total_score', target: 50000, reward: { currency: 500, gachaChests: 1 } }, { id: 'm11', description: '보스 1회 처치', type: 'boss_kills', target: 1, reward: { currency: 1000, gachaChests: 2 } },
        ];
        
        const ENHANCEMENTS = {
            'health': { name: '기본 체력 강화', description: (lvl) => `최대 체력 +${lvl * 5} 영구 증가`, maxLevel: 20, baseValue: 5 }, 'jelly_score': { name: '젤리 점수 강화', description: (lvl) => `모든 젤리 점수 +${lvl * 2}% 영구 증가`, maxLevel: 25, baseValue: 0.02 }, 'fever_duration': { name: '피버 시간 강화', description: (lvl) => `피버 시간 +${(lvl * 0.1).toFixed(1)}초 영구 증가`, maxLevel: 20, baseValue: 0.1 }, 'currency_gain': { name: '젤리 획득량 강화', description: (lvl) => `게임 종료 젤리 +${lvl * 2}% 영구 증가`, maxLevel: 25, baseValue: 0.02 }
        };
        const ENHANCEMENT_COST = (level, reduction = 0) => Math.floor(500 * Math.pow(1.2, level) * (1 - reduction));

        const LEVEL_UP_COST = (level, reduction = 0) => Math.floor((100 * Math.pow(level, 1.5)) * (1 - reduction));

        const getCharacterStat = (char, level) => char.baseStat + (level - 1) * 10;
        const getPetStat = (pet, level, isSynergy) => {
            let baseStat = 0;
            switch(pet.skill) {
                case 'health_potion': baseStat = Math.max(5, pet.baseStat - (level - 1)); break;
                case 'score_bonus': baseStat = pet.baseStat + (level - 1); break;
                case 'shield_item': baseStat = Math.max(10, pet.baseStat - (level - 1) * 2); break;
                case 'fever_boost': baseStat = pet.baseStat + (level - 1) * 0.5; break;
                case 'currency_boost': baseStat = pet.baseStat + (level - 1) * 2; break;
                case 'damage_negation': baseStat = pet.baseStat + (level - 1) * 0.5; break;
                case 'generate_bonus_jelly': baseStat = Math.max(10, pet.baseStat - (level - 1) * 1.5); break;
                case 'jelly_blast': baseStat = Math.max(20, pet.baseStat - (level - 1) * 3); break;
                case 'foresight': baseStat = Math.max(5, pet.baseStat - (level - 1)); break;
                case 'powerup_boost': baseStat = pet.baseStat + (level - 1); break;
                default: baseStat = pet.baseStat; break;
            }
            if (isSynergy) {
                 if (['health_potion', 'shield_item', 'generate_bonus_jelly', 'jelly_blast', 'foresight'].includes(pet.skill)) return baseStat * 0.8;
                 return baseStat * 1.2;
            }
            return baseStat;
        };
        
        // Game Object Icons
        const ObstacleLowIcon = () => React.createElement('div', { className: "w-full h-full bg-red-500 border-2 border-white rounded-md", style: { boxShadow: '0 0 10px #f00' } });
        const ObstacleHighIcon = () => React.createElement('div', { className: "w-full h-full bg-red-500 border-2 border-white rounded-md", style: { boxShadow: '0 0 10px #f00' } });
        const ObstacleSpikesIcon = () => React.createElement('div', { className: "w-full h-full bg-red-800 flex justify-around items-end p-1", style: { boxShadow: '0 0 10px #f00' } }, Array(5).fill(0).map((_, i) => React.createElement('div', { key: i, style: { width: '15%', height: '100%', background: 'white', clipPath: 'polygon(50% 0, 0 100%, 100% 100%)' } })));
        const ObstacleFallingIcon = () => React.createElement('div', { className: "w-full h-full bg-red-700 rounded-full border-2 border-white flex items-center justify-center", style: { boxShadow: '0 0 15px #f00', animation: 'spin 1s linear infinite' } }, '▼');
        const JellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-yellow-300", style: { boxShadow: '0 0 8px #ff0' } });
        const BigJellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-yellow-300 relative flex items-center justify-center", style: { boxShadow: '0 0 15px #ff0' } }, React.createElement('div', { className: "w-1/2 h-1/2 rounded-full bg-white/50" }));
        const RainbowBearJellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-2xl", style: { background: 'linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet)', animation: 'glow 1s ease-in-out infinite alternate', boxShadow: '0 0 20px #fff' } });
        const HealthPotionIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-green-400 border-2 border-white", style: { boxShadow: '0 0 10px #0f0' } });
        const GiantPotionIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-purple-500 border-2 border-white", style: { boxShadow: '0 0 10px #f0f' } });
        const BlastJellyIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-orange-500 border-2 border-white", style: { boxShadow: '0 0 10px #ff8c00' } });
        const ShieldItemIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-cyan-500 border-2 border-white", style: { boxShadow: '0 0 10px #0ff' } });
        const MagnetItemIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-blue-500 border-2 border-white", style: { boxShadow: '0 0 10px #00f' } });
        
        // New Boss Battle Icons
        const BossIcon = () => React.createElement('div', {className: 'w-full h-full'}, React.createElement(SvgIconWrapper, { color: "#f0f", filterId: "boss-glow" }, 
           React.createElement('path', { d: "M 50,10 L 90,40 L 80,90 L 20,90 L 10,40 Z", fill: "#333", stroke: "#f0f", strokeWidth: "4" }),
           React.createElement('circle', { cx: "50", cy: "45", r: "15", fill: "red", stroke: "white", strokeWidth: "2" }),
           React.createElement('path', { d: "M 30,70 L 40,60 L 60,60 L 70,70 Z", fill: "#555" })
        ));
        const EnergyCoreIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-cyan-300", style: { boxShadow: '0 0 15px #0ff', animation: 'glow 1.5s ease-in-out infinite' } });
        const BossProjectileIcon = () => React.createElement('div', { className: "w-full h-full rounded-full bg-red-500", style: { boxShadow: '0 0 10px #f00' } });
        const GazerLaserIcon = () => React.createElement('div', { className: "w-full h-full rounded-lg bg-gradient-to-r from-red-500 via-orange-300 to-red-500", style: { boxShadow: '0 0 15px #ff6347' } });

        // --- END OF MERGED constants.tsx ---

        // --- START OF MERGED App.tsx ---

        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        const useGameLoop = (callback, isRunning) => {
            const animationFrameId = useRef();
            const lastTime = useRef(performance.now());
            const loop = useCallback((time) => { const deltaTime = (time - lastTime.current) / 1000; lastTime.current = time; callback(deltaTime); animationFrameId.current = requestAnimationFrame(loop); }, [callback]);
            useEffect(() => { if (isRunning) { lastTime.current = performance.now(); animationFrameId.current = requestAnimationFrame(loop); } return () => { if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current); }; }, [isRunning, loop]);
        };

        const App = () => {
            const [playerData, setPlayerData] = useState(null);
            const [selectedCharId, setSelectedCharId] = useState('char1');
            const [selectedPetId, setSelectedPetId] = useState('pet1');
            const [activeOverlay, setActiveOverlay] = useState(null);
            const [hitFlash, setHitFlash] = useState(false);
            const [scale, setScale] = useState(1);
            const [gachaResult, setGachaResult] = useState(null);
            const [gachaState, setGachaState] = useState('idle'); // 'idle', 'animating', 'result'
            const [teamDetailView, setTeamDetailView] = useState(null);
            const [guildActiveTab, setGuildActiveTab] = useState('raid');
            
            const [gameState, setGameState] = useState({ status: 'menu', score: 0, distance: 0, gameSpeed: INITIAL_GAME_SPEED, isFeverTime: false, feverGauge: 0, feverTimeLeft: 0, isPaused: false, isLastDash: false, lastDashTimeLeft: 0, activeSkillCooldown: 0, worldLevel: 1, isRaidRun: false });
            const [bossState, setBossState] = useState({ isActive: false, health: 0, maxHealth: BOSS_MAX_HEALTH, attackTimer: 0, pattern: 'idle', pos: {x:0,y:0} });

            const playerStateRef = useRef(null);
            const gameObjectsRef = useRef([]);
            const nextSpawnDistanceRef = useRef(0);
            const petSkillTimerRef = useRef({});
            const inGameStatsRef = useRef({ jellies: 0, distance: 0, obstaclesDestroyed: 0, jumps: 0, fevers: 0, itemsUsed: 0, currentRunScore: 0, bossKills: 0 });
            const reviveUsedRef = useRef(false);
            const nextBossDistanceRef = useRef(BOSS_APPEARANCE_DISTANCE);
            const [, forceUpdate] = useState({});

            const activePartnerBonus = useMemo(() => { if (!playerData) return null; const comboKey = `${selectedCharId}_${selectedPetId}`; return PARTNER_BONUSES[comboKey] || null; }, [selectedCharId, selectedPetId, playerData]);
            
            useEffect(() => {
                const handleResize = () => { const newScale = Math.min(window.innerWidth / WORLD_WIDTH, window.innerHeight / WORLD_HEIGHT); setScale(newScale); };
                window.addEventListener('resize', handleResize);
                handleResize();
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            useEffect(() => {
                try {
                    const savedData = localStorage.getItem('ipkoDashDataV2');
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        // Data migration & validation
                        const initialEnhancements = { health: 0, jelly_score: 0, fever_duration: 0, currency_gain: 0 };
                        const initialMissions = {};
                        
                        parsedData.enhancements = { ...initialEnhancements, ...parsedData.enhancements };
                        parsedData.missions = { ...initialMissions, ...parsedData.missions };
                        if (!parsedData.treasures) parsedData.treasures = [];
                        if (!parsedData.equippedTreasures) parsedData.equippedTreasures = [];
                        if (parsedData.treasureChests) { parsedData.gachaChests = (parsedData.gachaChests || 0) + parsedData.treasureChests; delete parsedData.treasureChests; }
                        if (!parsedData.gachaChests) parsedData.gachaChests = 1;
                        if (!parsedData.memoryFragments) parsedData.memoryFragments = 0;
                        if (!parsedData.guildTokens) parsedData.guildTokens = 100; // Starting tokens for new system
                        if (!parsedData.guild) {
                            parsedData.guild = {
                                id: 'sim_guild', name: '네온 용사들', members: 5, raidBossHealth: GUILD_RAID_BOSS_MAX_HEALTH, raidBossMaxHealth: GUILD_RAID_BOSS_MAX_HEALTH, raidAttempts: 1, lastRaidContribution: 0,
                            };
                        }


                        // Add transcendence field if missing
                        Object.keys(parsedData.characters).forEach(charId => {
                           if (parsedData.characters[charId].transcendence === undefined) {
                               parsedData.characters[charId].transcendence = 0;
                           }
                        });

                        setPlayerData(parsedData);
                    } else {
                        const initialData = { characters: { 'char1': { level: 1, transcendence: 0 } }, pets: { 'pet1': { level: 1 } }, currency: 3000, highScore: 0, missions: {}, treasures: [], equippedTreasures: [], gachaChests: 3, enhancements: { health: 0, jelly_score: 0, fever_duration: 0, currency_gain: 0 }, memoryFragments: 0, guildTokens: 100, guild: { id: 'sim_guild', name: '네온 용사들', members: 5, raidBossHealth: GUILD_RAID_BOSS_MAX_HEALTH, raidBossMaxHealth: GUILD_RAID_BOSS_MAX_HEALTH, raidAttempts: 1, lastRaidContribution: 0 } };
                        setPlayerData(initialData);
                    }
                } catch (error) { console.error("Failed to load player data:", error); }
            }, []);

            useEffect(() => { if (playerData) { try { localStorage.setItem('ipkoDashDataV2', JSON.stringify(playerData)); } catch (error) { console.error("Failed to save player data:", error); } } }, [playerData]);
            
            const getTreasureValue = useCallback((type) => {
                if (!playerData?.equippedTreasures) return 0;
                return playerData.equippedTreasures.map(id => TREASURES[id]).filter(t => t && t.type === type).reduce((sum, t) => sum + t.value, 0);
            }, [playerData?.equippedTreasures]);
            
            const updateMissions = useCallback((stats) => {
                const isObserverEquipped = PETS[selectedPetId].skill === 'mission_progress_boost';
                const observerBonus = PETS[selectedPetId].baseStat;

                setPlayerData(prev => {
                    const newData = JSON.parse(JSON.stringify(prev));
                    let changed = false;
                    MISSIONS.forEach(mission => {
                        const missionProgress = newData.missions[mission.id] || { progress: 0, completed: false };
                        if (missionProgress.completed) return;
                        let progressToAdd = 0;
                        switch(mission.type) {
                            case 'collect_jellies': progressToAdd = stats.jellies; break; case 'run_distance': progressToAdd = stats.distance; break; case 'destroy_obstacles': progressToAdd = stats.obstaclesDestroyed; break; case 'jump_count': progressToAdd = stats.jumps; break; case 'fever_count': progressToAdd = stats.fevers; break; case 'use_items': progressToAdd = stats.itemsUsed; break; case 'single_run_score': if(stats.currentRunScore > missionProgress.progress) { missionProgress.progress = stats.currentRunScore; } break; case 'total_score': progressToAdd = stats.currentRunScore; break; case 'boss_kills': progressToAdd = stats.bossKills; break;
                        }
                        
                        if (isObserverEquipped && progressToAdd > 0) {
                           progressToAdd *= (1 + observerBonus);
                        }

                        if(progressToAdd > 0) missionProgress.progress += progressToAdd;
                        if (missionProgress.progress >= mission.target) { missionProgress.completed = true; }
                        newData.missions[mission.id] = missionProgress;
                        changed = true;
                    });
                    return changed ? newData : prev;
                });
            }, [selectedPetId]);

            const finalizeRun = useCallback(() => {
                if(gameState.isRaidRun) {
                    const damage = Math.floor(gameState.score / 5); // Score to damage conversion
                    setPlayerData(prev => {
                        const newData = JSON.parse(JSON.stringify(prev));
                        newData.guild.raidBossHealth = Math.max(0, newData.guild.raidBossHealth - damage);
                        newData.guild.lastRaidContribution = damage;
                        newData.guildTokens += Math.floor(damage / 100) + 10; // Participation reward
                        if (newData.guild.raidBossHealth <= 0) { // Boss defeated
                            newData.guildTokens += 500; // Defeat bonus
                            newData.guild.raidBossHealth = newData.guild.raidBossMaxHealth; // Reset boss
                        }
                        return newData;
                    });
                } else {
                    updateMissions(inGameStatsRef.current);
                    setPlayerData(prev => {
                        if (!prev) return null;
                        const newHighScore = Math.max(prev.highScore, gameState.score);
                        let petBonus = 1;
                        if(PETS[selectedPetId].skill === 'currency_boost') {
                            const petLevel = prev.pets[selectedPetId]?.level || 1;
                            const isSynergy = CHARACTERS[selectedCharId].skill === 'pet_boost';
                            petBonus = 1 + getPetStat(PETS[selectedPetId], petLevel, isSynergy) / 100;
                        }
                        if(activePartnerBonus?.type === 'currency_bonus_final') petBonus += activePartnerBonus.value;
                        const enhancementBonus = 1 + (prev.enhancements.currency_gain || 0) * ENHANCEMENTS.currency_gain.baseValue;
                        const earnedCurrency = Math.floor(gameState.score / 10 * petBonus * enhancementBonus);
                        return { ...prev, highScore: newHighScore, currency: Math.floor(prev.currency + earnedCurrency) };
                    });
                }
            }, [gameState.score, gameState.isRaidRun, selectedCharId, selectedPetId, activePartnerBonus, updateMissions]);

            const startGame = (isRaid = false) => {
                if(isRaid) {
                    if ((playerData.guild.raidAttempts || 0) < 1) return;
                    setPlayerData(prev => {
                        const newData = JSON.parse(JSON.stringify(prev));
                        newData.guild.raidAttempts -= 1;
                        return newData;
                    });
                }
                const character = CHARACTERS[selectedCharId];
                const pet = PETS[selectedPetId];
                const charLevel = playerData.characters[selectedCharId]?.level || 1;
                const enhancementBonus = (playerData.enhancements.health || 0) * ENHANCEMENTS.health.baseValue;
                let maxHealth = getCharacterStat(character, charLevel) + getTreasureValue('health_bonus') + enhancementBonus;
                if (activePartnerBonus?.type === 'max_health_bonus') maxHealth += activePartnerBonus.value;
                let baseSpeed = INITIAL_GAME_SPEED * (1 + getTreasureValue('speed_boost'));
                if (character.skill === 'high_speed') baseSpeed *= 1.2;
                playerStateRef.current = { pos: { x: PLAYER_X_POSITION, y: WORLD_HEIGHT - GROUND_HEIGHT - PLAYER_RUN_SIZE.y }, size: PLAYER_RUN_SIZE, vy: 0, health: maxHealth, maxHealth: maxHealth, isJumping: false, jumpCount: 0, rhythmJumpCombo: 0, transcendenceJumpCounter: 0, isSliding: false, hasShield: false, isGiant: false, isBlasting: false, hasMagnet: false, activeEffects: {}, skillTimers: { teleport: 5, interest: 10, protective_aura_pass: 0 }, jellyBlastCounter: 0 };
                if (character.skill === 'start_magnet') { playerStateRef.current.activeEffects['magnet'] = 5; }
                let initialFever = 0;
                if (pet.skill === 'fever_start_boost') { initialFever = FEVER_GAUGE_MAX * (pet.baseStat / 100); }
                gameObjectsRef.current = [];
                nextSpawnDistanceRef.current = 0;
                nextBossDistanceRef.current = BOSS_APPEARANCE_DISTANCE;
                petSkillTimerRef.current = { health_potion: 0, shield_item: 0, generate_bonus_jelly: 0, foresight: 0 };
                inGameStatsRef.current = { jellies: 0, distance: 0, obstaclesDestroyed: 0, jumps: 0, fevers: 0, itemsUsed: 0, currentRunScore: 0, bossKills: 0 };
                reviveUsedRef.current = false;
                setGameState({ status: 'playing', score: 0, distance: 0, gameSpeed: baseSpeed, isFeverTime: false, feverGauge: initialFever, feverTimeLeft: 0, isPaused: false, isLastDash: false, lastDashTimeLeft: 0, activeSkillCooldown: 0, worldLevel: 1, isRaidRun: isRaid });
                setBossState({ isActive: false, health: 0, maxHealth: BOSS_MAX_HEALTH, attackTimer: 0, pattern: 'idle', pos: {x:0,y:0} });
            };

            const triggerGameOver = () => {
                finalizeRun();
                setGameState(prev => ({ ...prev, status: 'gameOver' }));
            };

            const startLastDash = () => {
                if (gameState.isRaidRun) {
                    triggerGameOver();
                    return;
                }
                const pet = PETS[selectedPetId];
                if (pet.skill === 'revive' && !reviveUsedRef.current) {
                    reviveUsedRef.current = true;
                    let reviveHealth = 0.25;
                    if(activePartnerBonus?.type === 'revive_health_bonus') reviveHealth = activePartnerBonus.value;
                    playerStateRef.current.health = playerStateRef.current.maxHealth * reviveHealth;
                    return;
                }
                if (!gameState.isLastDash) {
                    let duration = LAST_DASH_DURATION;
                    if(CHARACTERS[selectedCharId].skill === 'last_dash_boost') duration *= 1.5;
                    setGameState(prev => ({...prev, isLastDash: true, lastDashTimeLeft: duration}));
                }
            };
            
            const startBossBattle = () => {
                setGameState(prev => ({ ...prev, status: 'boss_battle' }));
                setBossState({ isActive: true, health: BOSS_MAX_HEALTH, maxHealth: BOSS_MAX_HEALTH, attackTimer: 3, pattern: 'entering', pos: {x: WORLD_WIDTH - 250, y: 150} });
                gameObjectsRef.current = gameObjectsRef.current.filter(obj => !obj.type.startsWith('obstacle'));
            };
            
            const endBossBattle = (isWin) => {
                if(isWin) {
                    setGameState(prev => ({...prev, score: prev.score + 5000, worldLevel: prev.worldLevel + 1 }));
                    inGameStatsRef.current.bossKills++;
                    setPlayerData(prev => ({...prev, gachaChests: (prev.gachaChests || 0) + 1}));
                }
                setBossState(prev => ({ ...prev, isActive: false }));
                nextBossDistanceRef.current = gameState.distance + BOSS_APPEARANCE_DISTANCE;
                setTimeout(() => setGameState(prev => ({ ...prev, status: 'playing' })), 1000);
            };

            const togglePause = () => { setGameState(prev => ({ ...prev, isPaused: !prev.isPaused })); };
            
            const createBlast = (center, radius) => {
                const affected = [];
                gameObjectsRef.current.forEach(obj => {
                    if (obj.type.startsWith('obstacle') || obj.type === 'jelly' || obj.type === 'big_jelly' || obj.type.endsWith('_item') || obj.type.endsWith('_potion') || obj.type === 'blast_jelly') {
                        const objCenter = { x: obj.pos.x + obj.size.x / 2, y: obj.pos.y + obj.size.y / 2 };
                        const dist = Math.sqrt(Math.pow(objCenter.x - center.x, 2) + Math.pow(objCenter.y - center.y, 2));
                        if (dist < radius) { affected.push(obj.id); }
                    }
                });
                if (affected.length > 0) { 
                    const destroyedObstacles = gameObjectsRef.current.filter(obj => affected.includes(obj.id) && obj.type.startsWith('obstacle')).length;
                    inGameStatsRef.current.obstaclesDestroyed += destroyedObstacles; 
                    gameObjectsRef.current = gameObjectsRef.current.filter(obj => !affected.includes(obj.id)); 
                }
            };

            const spawnGameObject = useCallback(() => {
                const pattern = Math.random(); const newObjects = []; const basePos = { x: WORLD_WIDTH + 100, y: 0 }; const jellySize = {x: 20, y: 20}; const jellyY = WORLD_HEIGHT - GROUND_HEIGHT - jellySize.y - 10;
                if (Math.random() < 0.015) { newObjects.push({ id: Math.random(), type: 'rainbow_bear_jelly', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - 150 }, size: { x: 60, y: 80 }, Icon: RainbowBearJellyIcon }); } 
                else {
                    const character = CHARACTERS[selectedCharId]; let itemRoll = Math.random(); if (character.skill === 'item_boost') itemRoll *= 0.7;
                    if(itemRoll < 0.15) { 
                        const itemTypeRoll = Math.random(); let itemType = 'giant_potion'; let ItemIcon = GiantPotionIcon;
                        if(itemTypeRoll < 0.25) { itemType = 'blast_jelly'; ItemIcon = BlastJellyIcon; } else if(itemTypeRoll < 0.5) { itemType = 'shield_item'; ItemIcon = ShieldItemIcon; } else if(itemTypeRoll < 0.75) { itemType = 'magnet_item'; ItemIcon = MagnetItemIcon; }
                        newObjects.push({ id: Math.random(), type: itemType, pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - 120 }, size: {x: 40, y: 40}, Icon: ItemIcon });
                    } else {
                        if (pattern < 0.15) { const size = { x: 60, y: 50 }; newObjects.push({ id: Math.random(), type: 'obstacle_low', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleLowIcon }); }
                        else if (pattern < 0.25) { const size = { x: 80, y: 120 }; newObjects.push({ id: Math.random(), type: 'obstacle_high', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleHighIcon }); }
                        else if (pattern < 0.35) { const size = { x: 120, y: 40 }; newObjects.push({ id: Math.random(), type: 'obstacle_spikes', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleSpikesIcon }); }
                        else if (pattern < 0.45) { const size = { x: 50, y: 50 }; newObjects.push({ id: Math.random(), type: 'obstacle_falling', pos: { x: basePos.x + Math.random() * 100, y: -size.y }, size, Icon: ObstacleFallingIcon, vy: 0 }); }
                        else if (pattern < 0.6) { for (let i = 0; i < 8; i++) { const yOffset = Math.sin(i * 0.8) * 40; newObjects.push({ id: Math.random(), type: 'jelly', pos: { x: basePos.x + i * 50, y: jellyY + yOffset - 40 }, size: jellySize, Icon: JellyIcon }); } }
                        else if (pattern < 0.8) { const size = { x: 60, y: 50 }; newObjects.push({ id: Math.random(), type: 'obstacle_low', pos: { x: basePos.x, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleLowIcon }); for (let i = 0; i < 3; i++) newObjects.push({ id: Math.random(), type: 'jelly', pos: { x: basePos.x - 10 + i * 40, y: WORLD_HEIGHT - GROUND_HEIGHT - 120 }, size: jellySize, Icon: JellyIcon }); }
                        else { for (let i = 0; i < 3; i++) { const size = { x: 40, y: 40 }; newObjects.push({ id: Math.random(), type: 'obstacle_low', pos: { x: basePos.x + i * 150, y: WORLD_HEIGHT - GROUND_HEIGHT - size.y }, size, Icon: ObstacleLowIcon }); } }
                    }
                }
                gameObjectsRef.current.push(...newObjects); nextSpawnDistanceRef.current = gameState.distance + Math.random() * 300 + 250;
            }, [gameState.distance, selectedCharId]);
            
            const bossLogic = useCallback((deltaTime) => {
                let currentBoss = bossState;
                currentBoss.attackTimer -= deltaTime;

                if (currentBoss.attackTimer <= 0) {
                     const nextPattern = Math.random() > 0.5 ? 'laser' : 'missiles';
                     currentBoss.pattern = nextPattern;
                     currentBoss.attackTimer = 4; // reset timer
                     
                     if (nextPattern === 'laser') {
                         const isHigh = Math.random() > 0.5;
                         gameObjectsRef.current.push({ id: Math.random(), type: 'boss_laser', pos: { x: PLAYER_X_POSITION + 50, y: isHigh ? WORLD_HEIGHT - GROUND_HEIGHT - 150 : WORLD_HEIGHT - GROUND_HEIGHT - 50 }, size: { x: WORLD_WIDTH, y: 20 }, Icon: GazerLaserIcon, lifetime: 1.5 });
                     } else if (nextPattern === 'missiles') {
                         for(let i=0; i<3; i++) {
                             setTimeout(() => {
                                const xPos = PLAYER_X_POSITION + 200 + Math.random() * (WORLD_WIDTH / 2);
                                gameObjectsRef.current.push({ 
                                    id: Math.random(), 
                                    type: 'boss_projectile', 
                                    pos: { x: xPos, y: WORLD_HEIGHT },
                                    size: { x: 40, y: 40 }, 
                                    Icon: BossProjectileIcon, 
                                    vy: -700
                                });
                             }, i * 400);
                         }
                     }
                }
                
                // Spawn energy cores
                if(Math.random() < 0.02) {
                     gameObjectsRef.current.push({ id: Math.random(), type: 'energy_core', pos: { x: WORLD_WIDTH + 50, y: Math.random() * (WORLD_HEIGHT - GROUND_HEIGHT - 100) + 50 }, size: { x: 30, y: 30 }, Icon: EnergyCoreIcon });
                }

                setBossState(currentBoss);
            }, [bossState]);

            const gameLoop = useCallback((deltaTime) => {
                if (gameState.isPaused) return; const player = playerStateRef.current; if (!player) return; const character = CHARACTERS[selectedCharId]; const pet = PETS[selectedPetId]; const petLevel = playerData.pets[selectedPetId]?.level || 1; const isSynergy = CHARACTERS[selectedCharId].skill === 'pet_boost';
                
                setGameState(prev => ({...prev, activeSkillCooldown: Math.max(0, prev.activeSkillCooldown - deltaTime) }));
                if (gameState.status === 'boss_battle') { bossLogic(deltaTime); }

                // --- SPEED & MOVEMENT ---
                let speedMultiplier = 1; let speedIncreaseRate = GAME_SPEED_INCREASE_RATE;
                if (player.isBlasting) speedMultiplier = BLAST_JELLY_SPEED_MULTIPLIER;
                else if (player.activeEffects['shadow_pact'] > 0) speedMultiplier = 1.2;
                else if (character.skill === 'time_slow' && player.health < player.maxHealth * 0.5) { let slowDurBonus = activePartnerBonus?.type === 'slow_duration_bonus' ? activePartnerBonus.value : 0; speedMultiplier = 0.8 * (1 - slowDurBonus); }
                if (pet.skill === 'pace_keeper') { speedIncreaseRate *= (1 - pet.baseStat); }

                let newGameSpeed, actualSpeed, newDistance, newScore, newFeverGauge;
                if(gameState.isLastDash) { let newLastDashTimeLeft = gameState.lastDashTimeLeft - deltaTime; if(newLastDashTimeLeft <= 0) { triggerGameOver(); return; } player.health = 0; setGameState(prev => ({...prev, lastDashTimeLeft: newLastDashTimeLeft})); }
                newGameSpeed = gameState.gameSpeed + speedIncreaseRate * deltaTime; actualSpeed = newGameSpeed * speedMultiplier; newDistance = gameState.distance + actualSpeed * deltaTime; inGameStatsRef.current.distance += actualSpeed * deltaTime / 100; newScore = gameState.score; newFeverGauge = gameState.feverGauge;
                
                Object.keys(player.activeEffects).forEach(effect => { player.activeEffects[effect] -= deltaTime; if (player.activeEffects[effect] <= 0) { delete player.activeEffects[effect]; if(effect === 'giant') player.isGiant = false; if(effect === 'blast') player.isBlasting = false; if(effect === 'magnet') player.hasMagnet = false; } });
                player.vy -= GRAVITY * deltaTime; player.pos.y -= player.vy * deltaTime;
                if (player.pos.y > WORLD_HEIGHT - GROUND_HEIGHT - player.size.y) { player.pos.y = WORLD_HEIGHT - GROUND_HEIGHT - player.size.y; player.vy = 0; if (player.isJumping) { player.isJumping = false; player.jumpCount = 0; if (player.rhythmJumpCombo > 1) { newScore += player.rhythmJumpCombo * 100; } player.rhythmJumpCombo = 0; } }

                // --- HEALTH & FEVER ---
                let healthDecayMod = 1; if(activePartnerBonus?.type === 'health_decay_reduction') healthDecayMod = 1 - activePartnerBonus.value; if (!gameState.isFeverTime && !gameState.isLastDash && !gameState.isRaidRun) { player.health -= HEALTH_DECAY_RATE * (newGameSpeed / INITIAL_GAME_SPEED) * deltaTime * healthDecayMod; }
                let newFeverTimeLeft = gameState.feverTimeLeft; if (gameState.isFeverTime) { newFeverTimeLeft -= deltaTime; if (newFeverTimeLeft <= 0) { setGameState(prev => ({...prev, isFeverTime: false})); newFeverTimeLeft = 0; } }

                // --- SKILLS & PETS ---
                if (character.skill === 'random_teleport') { player.skillTimers.teleport -= deltaTime; if (player.skillTimers.teleport <= 0) { player.skillTimers.teleport = 5 + Math.random() * 5; if (Math.random() < 0.3) player.pos.x += 150; } }
                if (character.skill === 'interest_score') { player.skillTimers.interest -= deltaTime; if (player.skillTimers.interest <= 0) { player.skillTimers.interest = 10; newScore += Math.floor(gameState.score * 0.01); } }
                if (selectedCharId === 'char1' && (playerData.characters['char1']?.transcendence || 0) > 0 && player.transcendenceJumpCounter >= 10) {
                    player.transcendenceJumpCounter = 0; createBlast({ x: player.pos.x + player.size.x / 2, y: player.pos.y + player.size.y / 2 }, 150);
                }
                
                const petStat = getPetStat(pet, petLevel, isSynergy); let cooldownReduction = activePartnerBonus?.type === 'pet_cooldown_reduction' ? 1 - activePartnerBonus.value : 1;
                if (pet.skill === 'health_potion' || pet.skill === 'shield_item' || pet.skill === 'generate_bonus_jelly') { 
                    petSkillTimerRef.current[pet.skill] = (petSkillTimerRef.current[pet.skill] || 0) + deltaTime; 
                    if (petSkillTimerRef.current[pet.skill] >= (petStat * cooldownReduction)) { 
                        petSkillTimerRef.current[pet.skill] = 0; let type, Icon;
                        if (pet.skill === 'health_potion') { type = 'health_potion_item'; Icon = HealthPotionIcon; } else if (pet.skill === 'shield_item') { type = 'shield_item'; Icon = ShieldItemIcon; } else { type = 'big_jelly'; Icon = BigJellyIcon; }
                        gameObjectsRef.current.push({ id: Math.random(), type, pos: { x: WORLD_WIDTH + 50, y: WORLD_HEIGHT - GROUND_HEIGHT - 100 }, size: { x: 30, y: 30 }, Icon }); 
                    } 
                }
                 if (pet.skill === 'foresight') {
                    petSkillTimerRef.current.foresight = (petSkillTimerRef.current.foresight || 0) + deltaTime;
                    const foresightCooldown = getPetStat(pet, petLevel, isSynergy);
                    if (petSkillTimerRef.current.foresight >= foresightCooldown) {
                        petSkillTimerRef.current.foresight = 0; let found = false;
                        gameObjectsRef.current.forEach(obj => { obj.isHighlighted = false; }); // Clear previous
                        for (const obj of gameObjectsRef.current) { if (!found && obj.type.startsWith('obstacle') && obj.pos.x > player.pos.x) { obj.isHighlighted = true; found = true; break; } }
                    }
                }


                // --- COLLISIONS & OBJECTS ---
                const playerRect = { x: player.pos.x, y: player.pos.y, width: player.size.x, height: player.size.y }; const playerCenter = { x: player.pos.x + player.size.x / 2, y: player.pos.y + player.size.y / 2 };
                let rainbowBearCollected = false;
                const remainingGameObjects = [];
                for (const obj of gameObjectsRef.current) {
                    let currentSpeed = (gameState.status === 'boss_battle') ? INITIAL_GAME_SPEED : actualSpeed;
                    if (player.activeEffects['magnet'] > 0 && (obj.type === 'jelly' || obj.type === 'big_jelly' || obj.type === 'energy_core')) { const dist = Math.sqrt(Math.pow(obj.pos.x - playerCenter.x, 2) + Math.pow(obj.pos.y - playerCenter.y, 2)); if (dist < MAGNET_RADIUS) { obj.pos.x -= (obj.pos.x - playerCenter.x) * 0.1; obj.pos.y -= (obj.pos.y - playerCenter.y) * 0.1; } }
                    if (obj.type === 'obstacle_falling') { obj.vy = (obj.vy || 0) + GRAVITY * 0.3 * deltaTime; obj.pos.y += obj.vy * deltaTime; if (obj.pos.y > WORLD_HEIGHT) continue; }
                    
                    if (obj.vx) obj.pos.x += obj.vx * deltaTime; else obj.pos.x -= currentSpeed * deltaTime;
                    if (obj.vy) obj.pos.y += obj.vy * deltaTime;

                    if (obj.lifetime) { obj.lifetime -= deltaTime; if (obj.lifetime <= 0) continue; }
                    if (obj.pos.x < -obj.size.x) { continue; }

                    const objRect = { x: obj.pos.x, y: obj.pos.y, width: obj.size.x, height: obj.size.y };
                    let shouldKeep = true;
                    if (playerRect.x < objRect.x + objRect.width && playerRect.x + playerRect.width > objRect.x && playerRect.y < objRect.y + objRect.height && playerRect.y + playerRect.height > objRect.y) {
                        const isShadowPactActive = player.activeEffects['shadow_pact'] > 0;
                        const isAuraActive = player.activeEffects['protective_aura'] > 0;
                        
                        const handleJellyCollision = (isBig) => { inGameStatsRef.current.jellies++; player.jellyBlastCounter++; if (pet.skill === 'jelly_blast' && player.jellyBlastCounter >= petStat) { player.jellyBlastCounter = 0; createBlast(playerCenter, 150); } const petScoreBonus = (PETS[selectedPetId].skill === 'score_bonus') ? getPetStat(PETS[selectedPetId], petLevel, isSynergy) : 0; const treasureScoreBonus = 1 + getTreasureValue('score_bonus'); const jellyScoreBonus = activePartnerBonus?.type === 'jelly_score_bonus' ? 1 + activePartnerBonus.value : 1; const treasureJellyPercentBonus = 1 + getTreasureValue('base_jelly_score_percentage_bonus'); const enhancementBonus = 1 + (playerData.enhancements.jelly_score || 0) * ENHANCEMENTS.jelly_score.baseValue; let baseJellyScore = isBig ? 50 : 10; if (activePartnerBonus?.type === 'base_jelly_score_bonus') baseJellyScore += activePartnerBonus.value; const shadowPactMultiplier = isShadowPactActive ? 2 : 1; newScore += Math.floor((baseJellyScore + petScoreBonus) * treasureScoreBonus * jellyScoreBonus * treasureJellyPercentBonus * enhancementBonus * shadowPactMultiplier); if (!gameState.isFeverTime) { const petFeverBonus = (PETS[selectedPetId].skill === 'fever_boost') ? getPetStat(PETS[selectedPetId], petLevel, isSynergy) : 0; newFeverGauge = Math.min(FEVER_GAUGE_MAX, newFeverGauge + FEVER_GAUGE_PER_JELLY + petFeverBonus); } shouldKeep = false; };
                        const handleItemCollision = (itemType) => { inGameStatsRef.current.itemsUsed++; let effectMultiplier = (character.skill === 'item_double_effect') ? 2 : 1; let durationMultiplier = 1; if(PETS[selectedPetId].skill === 'powerup_boost') durationMultiplier += getPetStat(PETS[selectedPetId], petLevel, isSynergy) / 100; if(PETS[selectedPetId].skill === 'item_duration_boost') durationMultiplier += PETS[selectedPetId].baseStat; if(activePartnerBonus?.type === 'all_item_duration_bonus') durationMultiplier += activePartnerBonus.value; const finalDurationMultiplier = durationMultiplier * effectMultiplier; if (pet.skill === 'copy_item' && Math.random() < pet.baseStat) { gameObjectsRef.current.push({ ...obj, id: Math.random(), pos: {x: player.pos.x + 200, y: obj.pos.y} }); } switch(itemType) { case 'health_potion_item': player.health = Math.min(player.maxHealth, player.health + 20 * effectMultiplier); break; case 'giant_potion': player.isGiant = true; player.activeEffects['giant'] = GIANT_POTION_DURATION * (1 + getTreasureValue('giant_duration')) * finalDurationMultiplier; break; case 'blast_jelly': player.isBlasting = true; player.activeEffects['blast'] = BLAST_JELLY_DURATION * finalDurationMultiplier; break; case 'shield_item': player.hasShield = true; break; case 'magnet_item': player.hasMagnet = true; let magnetBonus = activePartnerBonus?.type === 'magnet_duration_bonus' ? 1 + activePartnerBonus.value : 1; player.activeEffects['magnet'] = MAGNET_ITEM_DURATION * (1 + getTreasureValue('magnet_duration')) * finalDurationMultiplier * magnetBonus; break; } shouldKeep = false; };
                        
                        if (obj.type === 'rainbow_bear_jelly') { newScore += 1000; newFeverGauge = FEVER_GAUGE_MAX; rainbowBearCollected = true; shouldKeep = false; }
                        else if (obj.type.endsWith('_item') || obj.type.endsWith('_potion') || obj.type === 'blast_jelly') { handleItemCollision(obj.type); }
                        else if (obj.type === 'jelly') { handleJellyCollision(false); }
                        else if (obj.type === 'big_jelly') { handleJellyCollision(true); }
                        else if (obj.type === 'energy_core') {
                            setBossState(prev => { const newHealth = prev.health - 100; if(newHealth <= 0) endBossBattle(true); return {...prev, health: newHealth }; });
                            shouldKeep = false;
                        } else if (obj.type.startsWith('obstacle') || obj.type === 'boss_laser' || obj.type === 'boss_projectile') {
                            const isLiftInvincible = player.isSliding && character.skill === 'slide_invincible';
                            if (gameState.isFeverTime || player.isGiant || player.isBlasting || gameState.isLastDash || isShadowPactActive || isAuraActive) {
                                if (isAuraActive && !player.skillTimers.protective_aura_pass) {
                                    newFeverGauge = Math.min(FEVER_GAUGE_MAX, newFeverGauge + 10);
                                    player.skillTimers.protective_aura_pass = obj.id; // Mark as passed
                                }
                                if(!obj.type.startsWith('boss') && !isAuraActive) { 
                                  inGameStatsRef.current.obstaclesDestroyed++; newScore += FEVER_OBSTACLE_SCORE; shouldKeep = false; 
                                }
                            }
                            else if (player.hasShield) { player.hasShield = false; if (character.skill === 'shield_blast') { createBlast(playerCenter, 200); } shouldKeep = false; }
                            else if (isLiftInvincible) { /* Pass through */ }
                            else if (pet.skill === 'damage_negation' && Math.random() * 100 < getPetStat(pet, petLevel, isSynergy)) { shouldKeep = false; }
                            else { player.health -= OBSTACLE_DAMAGE * deltaTime; setHitFlash(true); setTimeout(() => setHitFlash(false), 150); }
                        }
                    }
                    if (shouldKeep) {
                        // Reset aura pass check if player is no longer colliding with this obstacle
                        if (player.skillTimers.protective_aura_pass === obj.id && (playerRect.x >= objRect.x + objRect.width || playerRect.x + playerRect.width <= objRect.x)) {
                            player.skillTimers.protective_aura_pass = 0;
                        }
                        remainingGameObjects.push(obj);
                    }
                }
                if (rainbowBearCollected) { gameObjectsRef.current = remainingGameObjects.map(go => { if (go.type.startsWith('obstacle')) return { ...go, type: 'big_jelly', Icon: BigJellyIcon, size: { x: 30, y: 30 } }; return go; }); } else { gameObjectsRef.current = remainingGameObjects; }
                
                // --- UPDATE STATE ---
                inGameStatsRef.current.currentRunScore = newScore;
                let isFeverNow = gameState.isFeverTime; if (!isFeverNow && newFeverGauge >= FEVER_GAUGE_MAX) { isFeverNow = true; inGameStatsRef.current.fevers++; let feverDurBonus = activePartnerBonus?.type === 'fever_duration_bonus' ? 1 + activePartnerBonus.value : 1; const enhancementFeverBonus = (playerData.enhancements.fever_duration || 0) * ENHANCEMENTS.fever_duration.baseValue; newFeverTimeLeft = (FEVER_DURATION + enhancementFeverBonus) * (1 + getTreasureValue('fever_duration')) * feverDurBonus; newFeverGauge = 0; }
                if (newDistance > nextSpawnDistanceRef.current && gameState.status === 'playing' && !gameState.isRaidRun) spawnGameObject(); 
                if (player.health <= 0 && !gameState.isLastDash) { startLastDash(); }
                setGameState(prev => ({ ...prev, score: Math.floor(newScore), distance: newDistance, gameSpeed: newGameSpeed, isFeverTime: isFeverNow, feverGauge: newFeverGauge, feverTimeLeft: newFeverTimeLeft }));
                forceUpdate({});
            }, [gameState, playerData, selectedCharId, selectedPetId, spawnGameObject, activePartnerBonus, getTreasureValue, finalizeRun, bossLogic, bossState]);

            useGameLoop(gameLoop, (gameState.status === 'playing' || gameState.status === 'boss_battle') && !gameState.isPaused);

            const handleJump = useCallback(() => { if (gameState.status !== 'playing' && gameState.status !== 'boss_battle' || gameState.isPaused) return; const player = playerStateRef.current; if (!player || player.jumpCount >= 2 || player.isSliding) return; player.vy = PLAYER_JUMP_FORCE * (1 + getTreasureValue('jump_boost')); player.isJumping = true; player.jumpCount++; inGameStatsRef.current.jumps++; player.transcendenceJumpCounter++; if (CHARACTERS[selectedCharId].skill === 'rhythm_bonus') { player.rhythmJumpCombo++; if(player.rhythmJumpCombo === 5) { setGameState(prev => ({...prev, score: prev.score + 1000})); player.rhythmJumpCombo = 0; } } }, [gameState.status, gameState.isPaused, getTreasureValue, selectedCharId]);
            const handleJumpRelease = useCallback(() => { if (gameState.status !== 'playing' && gameState.status !== 'boss_battle' || gameState.isPaused) return; const player = playerStateRef.current; if (!player || player.vy <= 0) return; player.vy *= 0.5; }, [gameState.status, gameState.isPaused]);
            const handleSlide = useCallback((isSliding) => { if (gameState.status !== 'playing' && gameState.status !== 'boss_battle' || gameState.isPaused) return; const player = playerStateRef.current; if (!player || player.isJumping) return; player.isSliding = isSliding; const newSize = isSliding ? PLAYER_SLIDE_SIZE : PLAYER_RUN_SIZE; const oldY = player.pos.y + player.size.y; player.size = newSize; player.pos.y = oldY - newSize.y; }, [gameState.status, gameState.isPaused]);
            const handleActiveSkill = useCallback(() => {
                if ((gameState.status !== 'playing' && gameState.status !== 'boss_battle') || gameState.isPaused || gameState.activeSkillCooldown > 0) return;
                const player = playerStateRef.current;
                const character = CHARACTERS[selectedCharId];
                const pet = PETS[selectedPetId];
                let cooldown = 0; let skillUsed = false;
                
                if (character.skill === 'laser_beam') {
                    skillUsed = true; cooldown = character.cooldown; const laserY = player.pos.y + player.size.y / 2 - 15; const laserSizeY = 30;
                    gameObjectsRef.current.push({ id: Math.random(), type: 'gazer_laser', pos: { x: player.pos.x + player.size.x, y: laserY }, size: { x: WORLD_WIDTH, y: laserSizeY }, Icon: GazerLaserIcon, lifetime: 0.5 });
                    const affected = gameObjectsRef.current.filter(obj => obj.type.startsWith('obstacle') && obj.pos.y < laserY + laserSizeY && obj.pos.y + obj.size.y > laserY).map(o => o.id);
                    if (affected.length > 0) { inGameStatsRef.current.obstaclesDestroyed += affected.length; gameObjectsRef.current = gameObjectsRef.current.filter(obj => !affected.includes(obj.id)); }
                    if (bossState.isActive) { const bossRect = { x: bossState.pos.x, y: bossState.pos.y, width: 200, height: 200 }; if (bossRect.y < laserY + laserSizeY && bossRect.y + bossRect.height > laserY) { setBossState(prev => { const newHealth = prev.health - 300; if (newHealth <= 0) endBossBattle(true); return { ...prev, health: newHealth }; }); } }
                } else if (pet.skill === 'emp_blast') {
                    skillUsed = true; cooldown = pet.cooldown; createBlast({ x: player.pos.x, y: player.pos.y }, WORLD_WIDTH);
                } else if (character.skill === 'shadow_pact') {
                    if (player.health > player.maxHealth * 0.21) { // Safety margin
                        skillUsed = true; cooldown = character.cooldown; player.health -= player.maxHealth * 0.2; let duration = 5; if(activePartnerBonus?.type === 'shadow_pact_duration_bonus') duration += activePartnerBonus.value; player.activeEffects['shadow_pact'] = duration;
                    }
                } else if (character.skill === 'protective_aura') {
                    skillUsed = true; cooldown = character.cooldown; let duration = 4; if(activePartnerBonus?.type === 'protective_aura_duration_bonus') duration += activePartnerBonus.value; player.activeEffects['protective_aura'] = duration;
                }
                
                if (skillUsed) { let cooldownReduction = activePartnerBonus?.type === 'active_skill_cooldown_reduction' ? 1 - activePartnerBonus.value : 1; setGameState(prev => ({...prev, activeSkillCooldown: cooldown * cooldownReduction})); }
            }, [gameState, selectedCharId, selectedPetId, activePartnerBonus, bossState]);

            useEffect(() => {
                const onKeyDown = (e) => { if ((gameState.status !== 'playing' && gameState.status !== 'boss_battle') || e.repeat) return; if(e.code === 'Escape') togglePause(); if(gameState.isPaused) return; if (e.code === 'Space' || e.code === 'ArrowUp') handleJump(); if (e.code === 'ArrowDown' || e.code === 'KeyS') handleSlide(true); if (e.code === 'KeyF') handleActiveSkill(); };
                const onKeyUp = (e) => { if ((gameState.status !== 'playing' && gameState.status !== 'boss_battle') || gameState.isPaused) return; if (e.code === 'Space' || e.code === 'ArrowUp') handleJumpRelease(); if (e.code === 'ArrowDown' || e.code === 'KeyS') handleSlide(false); };
                window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp); return () => { window.removeEventListener('keydown', onKeyDown); window.removeEventListener('keyup', onKeyUp); };
            }, [gameState.status, gameState.isPaused, handleJump, handleSlide, handleJumpRelease, togglePause, handleActiveSkill]);

            const costReduction = getTreasureValue('cost_reduction');
            const handleLevelUp = (type, id) => {
                setPlayerData(prev => { if (!prev) return null; const isChar = type === 'character'; const data = isChar ? prev.characters[id] : prev.pets[id]; const meta = isChar ? CHARACTERS[id] : PETS[id]; if (data.level >= meta.maxLevel) return prev; const cost = LEVEL_UP_COST(data.level, costReduction); if (prev.currency < cost) return prev; const newData = JSON.parse(JSON.stringify(prev)); newData.currency -= cost; (isChar ? newData.characters[id] : newData.pets[id]).level++; return newData; });
            };
             const handleTranscend = (charId) => {
                setPlayerData(prev => {
                    const charData = prev.characters[charId]; const charMeta = CHARACTERS[charId];
                    if (!charData || charData.level < charMeta.maxLevel) return prev;
                    const currentTranscendence = charData.transcendence || 0;
                    if (currentTranscendence >= Object.keys(TRANSCENDENCE_BONUSES[charId] || {}).length) return prev; // Max transcendence reached
                    
                    const cost = TRANSCENDENCE_COST(currentTranscendence);
                    if ((prev.memoryFragments || 0) < cost) return prev;

                    const newData = JSON.parse(JSON.stringify(prev));
                    newData.memoryFragments -= cost;
                    newData.characters[charId].transcendence = currentTranscendence + 1;
                    return newData;
                });
            };
            const handleUnlock = (type, id) => {
                setPlayerData(prev => {
                    const isChar = type === 'character';
                    const item = isChar ? CHARACTERS[id] : PETS[id];
                    if (!prev || !item.unlockCost || prev.currency < item.unlockCost || (isChar ? prev.characters[id] : prev.pets[id])) return prev;
                    const newData = JSON.parse(JSON.stringify(prev));
                    newData.currency -= item.unlockCost;
                    if (isChar) { newData.characters[id] = { level: 1, transcendence: 0 }; } else { newData.pets[id] = { level: 1 }; }
                    return newData;
                });
            };
            const handleClaimMissionReward = (missionId) => {
                 setPlayerData(prev => { const mission = MISSIONS.find(m => m.id === missionId); const missionProgress = prev.missions[missionId]; if(!mission || !missionProgress || !missionProgress.completed || missionProgress.claimed) return prev; const newData = JSON.parse(JSON.stringify(prev)); newData.currency += mission.reward.currency; newData.gachaChests = (newData.gachaChests || 0) + mission.reward.gachaChests; newData.missions[missionId].claimed = true; return newData; });
            };
             const handleDrawGacha = () => {
                if (!playerData || (playerData.gachaChests || 0) < 1) return;
                
                setGachaState('animating');

                setTimeout(() => {
                    setPlayerData(prev => {
                        if (!prev || (prev.gachaChests || 0) < 1) {
                            setGachaState('idle');
                            return prev;
                        }
                        const newData = JSON.parse(JSON.stringify(prev));
                        newData.gachaChests--;

                        const luck = getTreasureValue('luck_boost');
                        const roll = Math.random();
                        let result = null;
                        const rarityColors = { epic: 'bg-purple-500/30 border-purple-400', rare: 'bg-blue-500/30 border-blue-400', uncommon: 'bg-green-500/30 border-green-400', common: 'bg-gray-500/30 border-gray-400' };
                        const allChars = Object.values(CHARACTERS);
                        const allPets = Object.values(PETS);

                        if (roll < 0.05 + luck * 0.1) { // Epic
                            const epicChars = allChars.filter(c => c.unlockCost > 3000 || c.skill.includes('laser') || c.skill.includes('shadow'));
                            const target = epicChars[Math.floor(Math.random() * epicChars.length)];
                            if (!newData.characters[target.id]) {
                                newData.characters[target.id] = { level: 1, transcendence: 0 };
                                result = { type: 'character', item: target, rarity: 'epic' };
                            } else {
                                newData.memoryFragments = (newData.memoryFragments || 0) + 50;
                                result = { type: 'fragments', amount: 50, rarity: 'epic', note: `${target.name} 중복` };
                            }
                        } else if (roll < 0.20 + luck * 0.2) { // Rare
                            const rarePets = allPets.filter(p => p.unlockCost > 1000 || p.skill.includes('emp'));
                            const target = rarePets[Math.floor(Math.random() * rarePets.length)];
                            if (!newData.pets[target.id]) {
                                newData.pets[target.id] = { level: 1 };
                                result = { type: 'pet', item: target, rarity: 'rare' };
                            } else {
                                newData.memoryFragments = (newData.memoryFragments || 0) + 20;
                                result = { type: 'fragments', amount: 20, rarity: 'rare', note: `${target.name} 중복` };
                            }
                        } else if (roll < 0.50 + luck * 0.3) { // Uncommon
                            const unowned = Object.values(TREASURES).filter(t => !newData.treasures.includes(t.id));
                            if (unowned.length > 0) {
                                const treasure = unowned[Math.floor(Math.random() * unowned.length)];
                                newData.treasures.push(treasure.id);
                                result = { type: 'treasure', item: treasure, rarity: 'uncommon' };
                            } else {
                                newData.currency += 1000;
                                result = { type: 'currency', amount: 1000, rarity: 'uncommon' };
                            }
                        } else { // Common
                            const amount = 250 + Math.floor(Math.random() * 751);
                            newData.currency += amount;
                            result = { type: 'currency', amount, rarity: 'common' };
                        }
                        
                        result.rarityColor = rarityColors[result.rarity];
                        setGachaResult(result);
                        setGachaState('result');
                        return newData;
                    });
                }, 2000);
            };
            const handleToggleEquipTreasure = (treasureId) => {
                setPlayerData(prev => { const newData = JSON.parse(JSON.stringify(prev)); const equipped = new Set(newData.equippedTreasures || []); if(equipped.has(treasureId)) { equipped.delete(treasureId); } else { if(equipped.size < 3) { equipped.add(treasureId); } } newData.equippedTreasures = Array.from(equipped); return newData; });
            };
            const handleUpgradeEnhancement = (id) => {
                setPlayerData(prev => { 
                    const currentLevel = prev.enhancements[id] || 0; 
                    const meta = ENHANCEMENTS[id]; 
                    if (currentLevel >= meta.maxLevel) return prev; 
                    const cost = ENHANCEMENT_COST(currentLevel, costReduction); 
                    if (prev.currency < cost) return prev; 
                    const newData = JSON.parse(JSON.stringify(prev)); 
                    newData.currency -= cost; 
                    newData.enhancements[id]++; 
                    return newData; 
                });
            };

            if (!playerData) { return React.createElement('div', { className: "w-screen h-screen flex items-center justify-center text-white glowing-text" }, "Loading..."); }
            
            const renderMenu = () => {
                const character = CHARACTERS[selectedCharId];
                const pet = PETS[selectedPetId];
                const charData = playerData.characters[selectedCharId] || { level: 1 };
                const petData = playerData.pets[selectedPetId] || { level: 1 };
                
                return React.createElement('div', { className: 'w-full h-full flex flex-col text-white' },
                    React.createElement('header', { className: 'w-full p-4 flex justify-between items-center text-lg' },
                        React.createElement('div', { className: 'flex items-center gap-4' },
                            React.createElement('div', { className: 'flex items-center gap-2 bg-black/30 px-3 py-1 rounded-full border border-gray-600' }, 'J', playerData.currency.toLocaleString()),
                            React.createElement('div', { className: 'flex items-center gap-2 bg-black/30 px-3 py-1 rounded-full border border-gray-600' }, '🛡️', playerData.guildTokens || 0)
                        ),
                        React.createElement('div', { className: 'flex items-center gap-4' },
                            React.createElement('div', { className: 'flex items-center gap-2 bg-black/30 px-3 py-1 rounded-full border border-gray-600' }, '🧩', playerData.memoryFragments || 0),
                            React.createElement('div', { className: 'flex items-center gap-2 bg-black/30 px-3 py-1 rounded-full border border-gray-600' }, '🎁', playerData.gachaChests || 0)
                        )
                    ),
                    React.createElement('main', { className: 'flex-grow flex flex-col items-center justify-center relative' },
                        React.createElement('h1', { className: 'absolute top-0 text-3xl font-black glowing-text' }, "잎코대쉬"),
                        React.createElement('div', { className: 'w-40 h-40 player-running', onClick: () => setActiveOverlay('team') }, React.createElement(character.Icon, null)),
                        React.createElement('div', { className: 'w-20 h-20 absolute bottom-[25%] right-[30%] player-running', style:{animationDuration: '0.6s'}, onClick: () => setActiveOverlay('team') }, React.createElement(pet.Icon, null)),
                         activePartnerBonus && React.createElement('div', { className: "bg-purple-500/20 border border-purple-400 p-2 rounded-lg text-center absolute top-12" },
                            React.createElement('p', { className: "font-bold text-sm text-purple-300" }, `✨ 짝꿍 효과: ${activePartnerBonus.name} ✨`),
                            React.createElement('p', { className: "text-xs text-purple-200" }, activePartnerBonus.description)
                        )
                    ),
                    React.createElement('footer', { className: 'p-4 flex flex-col items-center gap-4' },
                        React.createElement('div', {className: 'text-center'},
                             React.createElement('h2', {className: 'text-xl font-bold'}, `${character.name} Lv.${charData.level}`),
                             React.createElement('h3', {className: 'text-md text-gray-400'}, `${pet.name} Lv.${petData.level}`),
                        ),
                        React.createElement('button', { onClick: () => startGame(false), className: "w-full py-4 text-xl font-black ui-button" }, "GAME START"),
                        React.createElement('nav', { className: 'w-full flex justify-around p-2 bg-black/30 rounded-full border border-gray-700' },
                           React.createElement('button', { onClick: () => setActiveOverlay('team'), className: 'nav-button' }, '👥', React.createElement('span', null, '팀 편성')),
                           React.createElement('button', { onClick: () => setActiveOverlay('guild'), className: 'nav-button' }, '🛡️', React.createElement('span', null, '길드')),
                           React.createElement('button', { onClick: () => setActiveOverlay('enhancements'), className: 'nav-button' }, '🚀', React.createElement('span', null, '강화')),
                           React.createElement('button', { onClick: () => setActiveOverlay('gacha'), className: 'nav-button' }, '🎁', React.createElement('span', null, '뽑기')),
                           React.createElement('button', { onClick: () => setActiveOverlay('missions'), className: 'nav-button' }, '🎯', React.createElement('span', null, '미션')),
                           React.createElement('button', { onClick: () => setActiveOverlay('treasures'), className: 'nav-button' }, '💎', React.createElement('span', null, '보물'))
                        )
                    )
                );
            };

            const renderOverlay = (title, children, onClose) => (
                 React.createElement('div', { className: 'main-overlay overlay-fade-in' },
                    React.createElement('header', { className: 'p-4 flex items-center justify-between border-b border-gray-700' },
                        React.createElement('div', {className: 'w-8'}),
                        React.createElement('h2', { className: 'text-xl font-bold' }, title),
                        React.createElement('button', { onClick: onClose || (() => setActiveOverlay(null)), className: 'text-2xl font-bold w-8' }, '×')
                    ),
                    React.createElement('div', { className: 'flex-grow p-4 overflow-y-auto' }, children)
                 )
            );

            const renderTeamSelection = () => {
                 if (teamDetailView) {
                    const {type, id} = teamDetailView;
                    const isChar = type === 'character';
                    const item = isChar ? CHARACTERS[id] : PETS[id];
                    const data = isChar ? playerData.characters[id] : playerData.pets[id];
                    const level = data.level;
                    const isMaxLevel = level >= item.maxLevel;
                    const cost = LEVEL_UP_COST(level, costReduction);
                    const canAfford = playerData.currency >= cost;

                    const transcendenceLevel = data.transcendence || 0;
                    const hasTranscendence = isChar && TRANSCENDENCE_BONUSES[id];
                    const canTranscend = hasTranscendence && isMaxLevel && transcendenceLevel < Object.keys(TRANSCENDENCE_BONUSES[id] || {}).length;
                    const transcendCost = canTranscend ? TRANSCENDENCE_COST(transcendenceLevel) : 0;
                    const canAffordTranscend = playerData.memoryFragments >= transcendCost;

                    return renderOverlay(item.name, 
                        React.createElement('div', {className: 'flex flex-col items-center text-center'}, 
                           React.createElement(item.Icon, {className: 'w-32 h-32'}),
                           React.createElement('p', {className: 'mt-2 text-lg'}, `Lv. ${level}`),
                           React.createElement('p', {className: 'mt-2 text-gray-300'}, item.description),
                           React.createElement('div', {className: 'my-4 w-full bg-gray-700 h-px'}),
                           canTranscend ? 
                             React.createElement('div', {className: 'flex flex-col items-center'},
                                React.createElement('p', {className: 'text-lg font-bold text-purple-300'}, '초월 가능!'),
                                React.createElement('p', {className: 'mt-1 text-sm'}, TRANSCENDENCE_BONUSES[id][transcendenceLevel + 1].name),
                                React.createElement('p', {className: 'mt-1 text-xs text-gray-400'}, TRANSCENDENCE_BONUSES[id][transcendenceLevel + 1].description),
                                React.createElement('button', {onClick: () => handleTranscend(id), disabled: !canAffordTranscend, className: 'ui-button transcend-button mt-4'}, `초월하기 (${transcendCost} 🧩)`)
                             )
                           :
                             React.createElement('button', {onClick: () => handleLevelUp(type, id), disabled: isMaxLevel || !canAfford, className: 'ui-button'}, isMaxLevel ? 'MAX LEVEL' : `레벨업 (${cost} J)`),

                           hasTranscendence && transcendenceLevel > 0 && Array.from({length: transcendenceLevel}).map((_, i) => (
                             React.createElement('div', {key: i, className: 'mt-4 text-left w-full p-2 bg-purple-900/50 rounded-lg'}, 
                               React.createElement('p', {className: 'font-bold text-sm text-purple-300'}, `[초월 ${i+1}] ${TRANSCENDENCE_BONUSES[id][i+1].name}`),
                               React.createElement('p', {className: 'text-xs text-gray-300'}, TRANSCENDENCE_BONUSES[id][i+1].description)
                             )
                           ))
                        ), () => setTeamDetailView(null));
                 }

                const renderList = (items, type) => (
                    React.createElement('div', { className: 'flex-1 overflow-y-auto' },
                        React.createElement('div', { className: 'grid grid-cols-2 gap-4' },
                            Object.values(items).map(item => {
                                const isChar = type === 'character';
                                const isUnlocked = isChar ? !!playerData.characters[item.id] : !!playerData.pets[item.id];
                                const isSelected = isChar ? selectedCharId === item.id : selectedPetId === item.id;
                                
                                return React.createElement('div', { key: item.id, className: `selection-card p-2 text-center flex flex-col justify-between ${isSelected ? 'selected' : ''}` },
                                    isUnlocked ?
                                        React.createElement('div', {className:'flex flex-col items-center'},
                                            React.createElement('div', {onClick: () => isChar ? setSelectedCharId(item.id) : setSelectedPetId(item.id), className: 'w-16 h-16 mx-auto'}, React.createElement(item.Icon, null)),
                                            React.createElement('p', { className: "font-bold mt-1 text-sm" }, item.name),
                                            React.createElement('p', { className: "text-xs" }, `Lv. ${(isChar ? playerData.characters[item.id] : playerData.pets[item.id])?.level || 1}`),
                                            React.createElement('button', { onClick: () => setTeamDetailView({type, id: item.id}), className: 'text-xs mt-2 bg-gray-600 px-2 py-1 rounded' }, '상세 정보')
                                        )
                                    :
                                        React.createElement('div', {className:'flex flex-col items-center'},
                                            React.createElement('div', { className: "relative w-16 h-16 mx-auto opacity-70" }, React.createElement(item.Icon, null), React.createElement('div', { className: 'absolute inset-0 bg-black/70 rounded-lg flex items-center justify-center' }, '🔒')),
                                            React.createElement('p', { className: "font-bold mt-1 text-sm" }, item.name),
                                            item.guildShop ? React.createElement('p', { className: 'text-xs mt-2 text-purple-300' }, '길드 상점')
                                            : item.unlockCost ? React.createElement('button', { onClick: () => handleUnlock(type, item.id), disabled: playerData.currency < item.unlockCost, className: "w-full mt-2 ui-button text-xs py-1 px-2" }, `${item.unlockCost} J`) 
                                            : React.createElement('p', { className: 'text-xs mt-2' }, '획득 필요')
                                        )
                                );
                            })
                        )
                    )
                );
                 return renderOverlay('팀 편성',
                    React.createElement('div', { className: 'flex h-full gap-4' },
                        renderList(CHARACTERS, 'character'),
                        renderList(PETS, 'pet')
                    )
                 );
            };

            const renderEnhancements = () => renderOverlay('영구 강화', 
                React.createElement('div', { className: 'flex flex-col gap-4' },
                    Object.keys(ENHANCEMENTS).map(id => {
                        const enhancement = ENHANCEMENTS[id]; const level = playerData.enhancements[id] || 0; const cost = ENHANCEMENT_COST(level, costReduction); const isMaxLevel = level >= enhancement.maxLevel;
                        return React.createElement('div', { key: id, className: "bg-black/30 p-3 rounded-lg border border-gray-700" },
                            React.createElement('div', { className: 'flex justify-between items-start' },
                                React.createElement('div', null,
                                    React.createElement('p', { className: 'font-bold' }, `${enhancement.name} (Lv.${level})`),
                                    React.createElement('p', { className: 'text-sm text-gray-400 mt-1' }, enhancement.description(level))
                                ),
                                React.createElement('button', { onClick: () => handleUpgradeEnhancement(id), disabled: isMaxLevel || playerData.currency < cost, className: "ui-button text-sm flex-shrink-0" }, isMaxLevel ? "MAX" : `${cost} J`)
                            )
                        );
                    })
                )
            );

            const renderMissions = () => renderOverlay('미션', 
                React.createElement('div', { className: 'flex flex-col gap-3' },
                    MISSIONS.map(mission => {
                        const progress = playerData.missions[mission.id] || { progress: 0, completed: false };
                        const isComplete = progress.completed; const canClaim = isComplete && !progress.claimed;
                        return React.createElement('div', { key: mission.id, className: `p-3 rounded-lg border ${canClaim ? 'border-yellow-400' : 'border-gray-700'} bg-black/30` },
                            React.createElement('p', { className: "font-bold" }, mission.description),
                            React.createElement('div', { className: "progress-bar-container mt-2" }, React.createElement('div', { className: "h-2 progress-bar", style: { width: `${Math.min(100, (progress.progress / mission.target) * 100)}%`, background: '#0ff' } })),
                            React.createElement('div', { className: "flex justify-between items-center mt-1" },
                                React.createElement('p', { className: "text-xs text-gray-400" }, `${Math.floor(progress.progress)} / ${mission.target}`),
                                canClaim ? React.createElement('button', { onClick: () => handleClaimMissionReward(mission.id), className: "ui-button text-xs py-1" }, '보상 받기') :
                                isComplete ? React.createElement('span', { className: "text-xs text-green-400" }, '완료') : null
                            )
                        );
                    })
                )
            );

            const renderTreasures = () => renderOverlay('보물', 
                React.createElement('div', null,
                    React.createElement('h3', {className: 'font-bold text-lg mb-2'}, '보유 보물 (최대 3개 장착)'),
                    React.createElement('div', { className: 'grid grid-cols-2 gap-2' },
                        playerData.treasures.map(id => {
                            const treasure = TREASURES[id]; const isEquipped = playerData.equippedTreasures.includes(id);
                            return React.createElement('div', { key: id, onClick: () => handleToggleEquipTreasure(id), className: `p-3 text-center cursor-pointer rounded-lg border-2 ${isEquipped ? 'border-yellow-400 bg-yellow-500/20' : 'border-gray-600 bg-black/20'}` },
                                React.createElement('p', { className: "font-bold" }, treasure.name),
                                React.createElement('p', { className: "text-xs text-gray-400" }, treasure.description)
                            );
                        })
                    )
                )
            );
            
            const renderGacha = () => renderOverlay('네온 상자 뽑기',
                React.createElement('div', { className: 'flex flex-col items-center justify-center h-full text-center' },
                    gachaState === 'result' && gachaResult ?
                        React.createElement('div', { className: `fade-in flex flex-col items-center p-6 rounded-xl border-2 ${gachaResult.rarityColor}` },
                            React.createElement('p', { className: 'text-2xl font-bold mb-4' }, `획득! [${gachaResult.rarity.toUpperCase()}]`),
                            gachaResult.item?.Icon && React.createElement(gachaResult.item.Icon, { className: 'w-32 h-32' }),
                            React.createElement('p', { className: 'text-xl font-bold mt-2' }, gachaResult.item?.name || `+${gachaResult.amount}`),
                            React.createElement('p', { className: 'text-lg' }, gachaResult.type === 'currency' ? '젤리' : gachaResult.type === 'fragments' ? '메모리 조각' : ''),
                            gachaResult.note && React.createElement('p', {className: 'text-sm text-gray-400'}, `(${gachaResult.note})`),
                            React.createElement('button', { onClick: () => setGachaState('idle'), className: 'ui-button mt-8' }, '확인')
                        )
                    : gachaState === 'animating' ?
                        React.createElement('div', { className: 'flex flex-col items-center justify-center' },
                            React.createElement('p', { className: 'text-9xl', style: { animation: 'box-shake 0.4s ease-in-out 3' } }, '🎁'),
                            React.createElement('p', { className: 'text-xl font-bold mt-4 glowing-text' }, '개봉 중...')
                        )
                    : // idle state
                        React.createElement('div', { className: 'flex flex-col items-center' },
                            React.createElement('p', { className: 'text-9xl' }, '🎁'),
                            React.createElement('p', { className: 'text-2xl font-bold mt-4' }, '네온 상자'),
                            React.createElement('p', { className: 'text-3xl font-bold text-yellow-300 my-2' }, `x ${playerData.gachaChests || 0}`),
                            React.createElement('button', { onClick: handleDrawGacha, disabled: (playerData.gachaChests || 0) < 1, className: "ui-button" }, "1개 열기")
                        )
                ), () => { setGachaState('idle'); setGachaResult(null); setActiveOverlay(null); }
            );

            const renderGuild = () => {
                const guild = playerData.guild;

                const handleBuyGuildItem = (itemType, itemId, cost) => {
                    setPlayerData(prev => {
                        if (prev.guildTokens < cost) return prev;
                        const newData = JSON.parse(JSON.stringify(prev));
                        if(itemType === 'character' && !newData.characters[itemId]) {
                            newData.guildTokens -= cost;
                            newData.characters[itemId] = { level: 1, transcendence: 0 };
                        } else if(itemType === 'pet' && !newData.pets[itemId]) {
                            newData.guildTokens -= cost;
                            newData.pets[itemId] = { level: 1 };
                        }
                        return newData;
                    });
                };
                
                const renderRaid = () => (
                    React.createElement('div', {className: 'flex flex-col items-center text-center'},
                        React.createElement('h3', {className: 'text-2xl font-bold text-red-400 glowing-text'}, '길드 레이드'),
                        React.createElement('p', {className: 'text-sm text-gray-400 mb-4'}, '길드원과 협력하여 보스를 처치하세요!'),
                        React.createElement('div', {className: 'w-48 h-48 my-4', style: { animation: 'raid-boss-idle 3s ease-in-out infinite' }},
                           React.createElement(SvgIconWrapper, { color: '#f00', filterId: 'raid-boss-glow' },
                             React.createElement('path', { d: "M50 10 C 20 20, 20 80, 50 90 S 80 80, 80 20 Z", fill: '#400' }),
                             React.createElement('path', { d: "M30 40 L70 40 L50 60 Z", fill: 'red' }),
                             React.createElement('circle', { cx: 35, cy: 30, r: 5, fill: 'yellow' }),
                             React.createElement('circle', { cx: 65, cy: 30, r: 5, fill: 'yellow' })
                           )
                        ),
                        React.createElement('div', {className: 'w-full max-w-sm'},
                          React.createElement('p', {className: 'font-bold'}, `보스 체력: ${guild.raidBossHealth.toLocaleString()} / ${guild.raidBossMaxHealth.toLocaleString()}`),
                          React.createElement('div', { className: "progress-bar-container mt-1" }, React.createElement('div', { className: "h-4 progress-bar boss-health-bar", style: { width: `${(guild.raidBossHealth / guild.raidBossMaxHealth) * 100}%` } })),
                        ),
                        React.createElement('p', {className: 'mt-4 text-lg'}, `오늘 남은 공격 횟수: ${guild.raidAttempts}`),
                        React.createElement('p', {className: 'text-sm text-gray-300'}, `나의 마지막 기여도: ${guild.lastRaidContribution.toLocaleString()}`),
                        React.createElement('button', {onClick: () => startGame(true), disabled: guild.raidAttempts < 1, className: 'ui-button raid-button mt-6'}, '레이드 시작')
                    )
                );
                
                const renderShop = () => {
                    const shopItems = [
                        { type: 'character', id: 'char17', cost: 500 },
                        { type: 'pet', id: 'pet17', cost: 400 },
                    ];
                    return React.createElement('div', {className: 'flex flex-col gap-4'},
                       shopItems.map(shopItem => {
                           const item = shopItem.type === 'character' ? CHARACTERS[shopItem.id] : PETS[shopItem.id];
                           const isUnlocked = shopItem.type === 'character' ? !!playerData.characters[item.id] : !!playerData.pets[item.id];
                           return React.createElement('div', {key: item.id, className: 'flex items-center justify-between p-2 bg-black/30 rounded-lg border border-gray-700'},
                             React.createElement('div', {className: 'flex items-center gap-3'},
                               React.createElement(item.Icon, {className: 'w-12 h-12'}),
                               React.createElement('div', null,
                                 React.createElement('p', {className: 'font-bold'}, item.name),
                                 React.createElement('p', {className: 'text-xs text-gray-400'}, item.description)
                               )
                             ),
                             React.createElement('button', {onClick: () => handleBuyGuildItem(shopItem.type, shopItem.id, shopItem.cost), disabled: isUnlocked || playerData.guildTokens < shopItem.cost, className: 'ui-button text-sm'},
                               isUnlocked ? '보유중' : `${shopItem.cost} 🛡️`
                             )
                           );
                       })
                    );
                };

                return renderOverlay('길드',
                    React.createElement('div', {className: 'flex flex-col h-full'},
                       React.createElement('div', {className: 'flex justify-center border-b border-gray-700 mb-4'},
                         React.createElement('button', {onClick: () => setGuildActiveTab('raid'), className: `tab-button ${guildActiveTab === 'raid' && 'active'}`}, '레이드'),
                         React.createElement('button', {onClick: () => setGuildActiveTab('shop'), className: `tab-button ${guildActiveTab === 'shop' && 'active'}`}, '상점')
                       ),
                       guildActiveTab === 'raid' && renderRaid(),
                       guildActiveTab === 'shop' && renderShop()
                    )
                );
            };

            const renderGame = () => {
                const player = playerStateRef.current; if (!player) return null;
                const CurrentCharacterIcon = CHARACTERS[selectedCharId].Icon;
                let playerClass = 'player-running'; if(player.isGiant) playerClass = 'player-giant'; else if (player.isJumping) playerClass = player.vy > 0 ? 'player-jumping' : 'player-falling';
                if(player.activeEffects['shadow_pact'] > 0) playerClass += ' shadow-form-effect';
                let playerTransform = ''; if(player.isBlasting) playerTransform = `translateX(${Math.random()*10 - 5}px)`;
                const character = CHARACTERS[selectedCharId];
                const pet = PETS[selectedPetId];
                const hasActiveSkill = character.skill === 'laser_beam' || pet.skill === 'emp_blast' || character.skill === 'shadow_pact' || character.skill === 'protective_aura';

                return React.createElement('div', { className: "relative w-full h-full overflow-hidden" },
                    hitFlash && React.createElement('div', { className: "hit-flash-overlay" }),
                    gameState.isLastDash && React.createElement('div', { className: "last-dash-overlay" }),
                    gameState.isFeverTime && React.createElement('div', { className: "fever-active-overlay" }),
                    React.createElement('div', { className: "absolute top-0 left-0", style: { width: WORLD_WIDTH, height: WORLD_HEIGHT } },
                        bossState.isActive && React.createElement('div', { className: "absolute", style: { left: bossState.pos.x, top: bossState.pos.y, width: 200, height: 200, animation: 'boss-idle 2s ease-in-out infinite' }}, React.createElement(BossIcon, null)),
                        React.createElement('div', { className: `absolute ${playerClass}`, style: { left: player.pos.x, top: player.pos.y, width: player.size.x, height: player.size.y, transform: playerTransform, transition: 'width 0.1s, height 0.1s' } },
                           React.createElement(CurrentCharacterIcon, null),
                           player.hasShield && React.createElement('div', { className: 'shield-effect' }),
                           player.activeEffects['protective_aura'] > 0 && React.createElement('div', { className: 'paladin-aura-effect' })
                        ),
                        gameObjectsRef.current.map(obj => React.createElement('div', { key: obj.id, className: `absolute ${obj.isHighlighted ? 'obstacle-highlight' : ''}`, style: { left: obj.pos.x, top: obj.pos.y, width: obj.size.x, height: obj.size.y } }, React.createElement(obj.Icon, null))),
                        React.createElement('div', { className: "absolute bottom-0 left-0 w-full bg-cyan-800", style: { height: GROUND_HEIGHT, boxShadow: '0 -10px 20px rgba(0, 255, 255, 0.5)' } })
                    ),
                    React.createElement('div', { className: "absolute top-2 left-4 right-4 text-white font-bold flex flex-col gap-2" },
                         bossState.isActive && React.createElement('div', null,
                            React.createElement('p', {className: 'text-center text-red-400 text-lg font-black glowing-text mb-1'}, 'BOSS'),
                            React.createElement('div', { className: "progress-bar-container" }, React.createElement('div', { className: "h-4 progress-bar boss-health-bar", style: { width: `${(bossState.health / bossState.maxHealth) * 100}%` } }))
                         ),
                         React.createElement('div', { className: "flex items-center gap-4"},
                            React.createElement('div', { className: 'text-2xl' }, `SCORE: ${gameState.score}`),
                            React.createElement('div', { className: 'flex-grow flex flex-col gap-1' },
                                !gameState.isRaidRun && React.createElement('div', { className: "progress-bar-container" }, React.createElement('div', { className: "h-3 progress-bar health-bar", style: { width: `${(player.health / player.maxHealth) * 100}%` } })),
                                React.createElement('div', { className: "progress-bar-container" }, React.createElement('div', { className: "h-2 progress-bar fever-bar", style: { width: `${(gameState.feverGauge / FEVER_GAUGE_MAX) * 100}%` } }))
                            ),
                            React.createElement('button', {onClick: togglePause, className: "w-10 h-10 p-1 flex-shrink-0"}, 
                              React.createElement('svg', { viewBox: "0 0 100 100", fill: "white" }, 
                                React.createElement('rect', { x: "25", y: "15", width: "15", height: "70", rx:"5" }),
                                React.createElement('rect', { x: "60", y: "15", width: "15", height: "70", rx:"5" })
                              )
                            )
                        )
                    ),
                    React.createElement('div', { className: "control-button left-4", onMouseDown: handleJump, onMouseUp: handleJumpRelease, onTouchStart: (e) => { e.preventDefault(); handleJump(); }, onTouchEnd: (e) => { e.preventDefault(); handleJumpRelease(); } }, React.createElement('span', { className: "text-5xl text-white/80" }, "↑")),
                    React.createElement('div', { className: "control-button right-4", onMouseDown: () => handleSlide(true), onMouseUp: () => handleSlide(false), onTouchStart: (e) => { e.preventDefault(); handleSlide(true); }, onTouchEnd: (e) => { e.preventDefault(); handleSlide(false); } }, React.createElement('span', { className: "text-5xl text-white/80" }, "↓")),
                    hasActiveSkill && React.createElement('button', { className: "control-button skill-button", onClick: handleActiveSkill, disabled: gameState.activeSkillCooldown > 0}, 
                        React.createElement('span', { className: "text-4xl text-white/80" }, "⚡️"),
                        gameState.activeSkillCooldown > 0 && React.createElement('div', {className: 'cooldown-overlay'}, Math.ceil(gameState.activeSkillCooldown))
                    )
                );
            };

            const renderGameOver = () => React.createElement('div', { className: "main-overlay overlay-fade-in items-center justify-center p-4" },
                React.createElement('div', { className: "bg-slate-800/80 border-2 border-cyan-400 rounded-2xl p-8 text-center shadow-lg shadow-cyan-500/20 fade-in w-full max-w-md" },
                    React.createElement('h2', { className: "text-5xl font-black text-red-500 glowing-text" }, gameState.isRaidRun ? "RAID COMPLETE" : "GAME OVER"),
                    React.createElement('p', { className: "mt-4 text-2xl" }, gameState.isRaidRun ? "Boss Damage:" : "Final Score:", React.createElement('span', { className: "text-cyan-300 font-bold" }, gameState.isRaidRun ? Math.floor(gameState.score / 5).toLocaleString() : gameState.score)),
                    !gameState.isRaidRun && React.createElement('p', { className: "mt-2 text-xl" }, "High Score: ", React.createElement('span', { className: "text-yellow-300 font-bold" }, playerData.highScore)),
                    React.createElement('p', { className: "mt-2 text-xl" }, gameState.isRaidRun ? "Earned Guild Tokens:" : "Earned Jellies:", React.createElement('span', { className: "text-yellow-300 font-bold" }, `+${gameState.isRaidRun ? (Math.floor(gameState.score / 500) + 10) : Math.floor(gameState.score / 10)}`)),
                    React.createElement('button', { onClick: () => setGameState(prev => ({ ...prev, status: 'menu' })), className: "mt-8 px-8 py-3 ui-button" }, "메인 메뉴")
                )
            );

            const renderPauseMenu = () => React.createElement('div', { className: "main-overlay overlay-fade-in items-center justify-center p-4" },
                React.createElement('div', { className: "bg-slate-800/80 border-2 border-cyan-400 rounded-2xl p-8 text-center shadow-lg shadow-cyan-500/20 fade-in flex flex-col gap-4 w-full max-w-md" },
                    React.createElement('h2', { className: "text-5xl font-black text-white glowing-text" }, "PAUSED"),
                    React.createElement('button', { onClick: togglePause, className: "px-8 py-3 ui-button" }, "게임 재개"),
                    React.createElement('button', { onClick: () => { finalizeRun(); setGameState(prev => ({ ...prev, status: 'menu' })); }, className: "px-8 py-3 ui-button" }, "메인 메뉴")
                )
            );
            
            return React.createElement('div', { className: "relative w-screen h-screen bg-black text-white flex items-center justify-center overflow-hidden font-sans antialiased select-none" },
                React.createElement('div', { className: "scrolling-background", style: { filter: `hue-rotate(${ (gameState.worldLevel -1) * 60 }deg)` } }),
                 React.createElement('div', { className: "relative overflow-hidden bg-black/20", style: { width: WORLD_WIDTH, height: WORLD_HEIGHT, transform: `scale(${scale})`, transformOrigin: 'center center' } },
                    gameState.status === 'menu' && renderMenu(),
                    (gameState.status === 'playing' || gameState.status === 'gameOver' || gameState.status === 'boss_battle') && renderGame(),
                    gameState.status === 'gameOver' && renderGameOver(),
                    gameState.isPaused && renderPauseMenu(),
                    activeOverlay === 'team' && renderTeamSelection(),
                    activeOverlay === 'enhancements' && renderEnhancements(),
                    activeOverlay === 'missions' && renderMissions(),
                    activeOverlay === 'treasures' && renderTreasures(),
                    activeOverlay === 'gacha' && renderGacha(),
                    activeOverlay === 'guild' && renderGuild()
                )
            );
        };

        // --- END OF MERGED App.tsx ---

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(React.StrictMode, null, React.createElement(App, null)));
    </script>
  </body>
</html>